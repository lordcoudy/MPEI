unit UnLAB1;
Interface       // раздел описани€ межмодульного интерфейса

Uses     
  SysUtils;   

Const
  SymbTable = '0123456789јЅ¬√ƒ≈®∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяzyxwvutsrqponmlkjihgfedcba';

Const
  Cifr : set of '0'.. '9' = ['0'.. '9'];
  BukvKir: set of char = ['ј'.. 'я', '®'];
  BukvLat: set of char = ['a'.. 'z'];

Function Prov1(const s: ANSIString): Byte; // проверка без SymbTable
Function Prov2(const s: ANSIString): Byte; // проверка с SymbTable
Procedure Sort1(var s: ANSIString);  // сортировка без SymbTable
Procedure Sort2(var s: ANSIString);  // сортировка с SymbTable

Implementation  // раздел реализации и описани€ закрытых процедур

Function Prov1; // проверка без SymbTable
Var
  Nom: byte; // номер аномалии
  i,Len: word; // текущий символ и длина строки
Begin
  Nom:=0; len:= Length(S);
  If Len=0 then Nom:=1
  Else
    Begin
      i:=1;
      while (i<=Len) and (Nom=0) do
      begin
        if Not ((S[i] in Cifr) or (S[i] in BukvKir) or (S[i] in BukvLat)) then Nom:=2;
        Inc(i);
      end;
    End;
  Prov1:=Nom; 
End;

Function Prov2; // проверка с SymbTable
Var
  Nom: byte; // номер аномалии
  i,Len: word; // текущий символ и длина строки
Begin
  Nom:=0; len:= Length(S);
  If Len=0 then Nom:=1
  Else
    Begin
      i:=1;
      while (i<=Len) and (Nom=0) do
      begin
        if Not (Pos(S[i], SymbTable)>0) then Nom:=2;
        Inc(i);
      end;
    End;
  Prov2:=Nom; 
End;

Procedure Sort1;  // сортировка без SymbTable
Var 
  i, z, len: Word; // номер текущего символа, номер итерации (шага), длина строки
  flag: Boolean; // упор€дочено? (нет обменов?)
  ch: char; // дл€ обмена
Begin
  Z:=1;  len:=length(s);
  Repeat // пузырЄк
    flag:=true;
    for i:=1 to len-z do
      if (s[i] in BukvLat) and ((s[i+1] in Cifr) or (s[i+1] in BukvKir)) or    //латинские буквы Ђлегчеї всех
         (s[i] in BukvKir) and (s[i+1] in Cifr) or       // кириллица Ђлегчеї цифр Ц всплывает
         (s[i] in Cifr) and (s[i+1] in Cifr) and (s[i]>s[i+1]) or     // обе цифры Ц по возрастанию
         (s[i] in BukvLat) and (s[i+1] in BukvLat) and (s[i]<s[i+1])    // обе латинские буквы Ц от z до a
      then
      begin // обмен
        ch:=s[i]; s[i]:=s[i+1]; s[i+1]:=ch; flag:= false;
      end;
    inc(z);
  Until flag or (z=len);
End; 

Procedure Sort2;  // сортировка с SymbTable
Var 
  i, z, len: Word; // номер текущего символа, номер итерации (шага), длина строки
  flag: Boolean; // упор€дочено? (нет обменов?)
  ch: char; // дл€ обмена
Begin
  z:=1;  len:=length(s);
  Repeat // пузырЄк
    flag:=true;
    for i:=1 to len-z do
      if (Pos(s[i], SymbTable) > Pos(s[i+1], SymbTable))  // неправильный пор€док по своей Ђтаблицеї
        and not ((s[i] in BukvKir) and (s[i+1] in BukvKir)) // но кириллицу не упор€дочивать
      then
      begin // обмен
        ch:=s[i]; s[i]:=s[i+1]; s[i+1]:=ch; flag:= false;
      end;
    inc(z);
  Until flag or (z=len);
End; 

end.

