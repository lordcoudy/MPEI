<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>
		Тема: «Объектно-ориентированное программирование в PHP. Примеры»<br>
		Реферат<br>
		по дисциплине «WEB-технологии»<br>
		Выполнил:<br>
		Студент группы А-08-19 Балашов С.А.<br>
		Принял:<br>
		асс. Мишин А.А.<br>
		Москва, 2021
	</title>
	<link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>
	<div id="top">Return to top</div>
	<button onclick="topFunction()" id="scrollBtn" title="Scroll back">&#8593</button>
	<div id="toggle">Toggle dark mode</div>
	<label class="switch">
	  <input type="checkbox">
	  <span class="slider round" onclick="toggleDarkMode()"></span>
	</label>
	<div class="content">
		<button class="content_button"><h2>Содержание</h2></button>
		<div class="dropdown-content">
			<ul>
			<li><a href="#intro">1. Введение</a></li>
			<li><a href="#libraries">2. Организация библиотек</a></li>
			<ul>
				<li><a href="#libraries_connection">2.1. Подключение файла библиотеки</a></li>
				<li><a href="#libraries_conflicts">2.2. Разрешение конфликтов имен</a></li>
				<li><a href="#libraries_autoload">2.3. Автоматическая загрузка классов</a></li>
				<li><a href="#libraries_main_script">2.4. Главный файл скрипта</a></li>
				<li><a href="#libraries_interface">2.5. Интерфейс библиотеки</a></li>
				<li><a href="#libraries_inheritage">2.6. Наследование и расширение модулей</a></li>
			</ul>
			<li><a href="#classes_and_hides">3. Классы и сокрытие данных</a></li>
			<ul>
				<li><a href="#classes_and_hides_datatype">3.1. Класс как тип данных</a></li>
				<li><a href="#classes_and_hides_creating">3.2. Создание нового класса</a></li>
				<li><a href="#classes_and_hides_work">3.3. Работа с классами</a></li>
				<li><a href="#classes_and_hides_initializing">3.4. Инициализация и разрушение</a></li>
				<li><a href="#classes_and_hides_access">3.5. Права доступа к членам класса</a></li>
			</ul>
			<li><a href="#inheritage_and_virtual_methods">4. Наследование и виртуальные методы</a></li>
			<ul>
				<li><a href="#inheritage_and_virtual_methods_dot">4.1. Расширение класса</a></li>
				<li><a href="#inheritage_and_virtual_methods_polymorfism">4.2. Полиморфизм</a></li>
				<li><a href="#inheritage_and_virtual_methods_interfaces">4.3. Интерфейсы</a></li>
			</ul>
			<li><a href="#errors_and_exceptions">5. Обработка ошибок и исключения</a></li>
			<ul>
				<li><a href="#errors_and_exceptions_errors">5.1. Ошибки</a></li>
				<li><a href="#errors_and_exceptions_exceptions">5.2. Исключения</a></li>
			</ul>
			<li><a href="#Iterators_arrays">6. Итераторы, массивы</a></li>
			<ul>
				<li><a href="#Iterators_arrays_access">6.1. Неявный доступ к классам и методам</a></li>
				<li><a href="#Iterators_arrays_iterators">6.2. Итераторы</a></li>
				<li><a href="#Iterators_arrays_virtual_methods">6.3. Виртуальные массивы</a></li>
			</ul>
			<li><a href="#Conclusion">7. Заключение</a></li>
			<li><a href="#Literature">8. Список использованной литературы</a></li>
		</ul>
		</div>
	</div>
	<div id="article">
		<div id="intro">
		  <h2>1. Введение</h2>
		  <p>Большинство современных языков программирования используют методологию объектно-ориентированного программирования (ООП). Она позволяет представить программу в виде совокупности объектов, каждый из которых является частью определенного класса. В свою очередь классы образуют иерархию наследования.</p>
		  <p>Такой подход позволяет проще работать с крупными проектами за счет разбиения программы на своеобразные модули, каждый из которых выполняет определенную задачу. Несмотря на снижение производительности программ при использовании ООП из-за нескольких слоев абстракции, инкапсуляции и динамического связывания методов, данный подход является на текущий момент самым популярным благодаря схожести с естественными языками.</p>
		  <p>В этом реферате я рассмотрю ООП в языке PHP - скриптовом языке общего назначения, входящий в Топ-10<a href="#top10" id="ref-1"><sup>1</sup></a> популярных языков программирования на момент ноября 2021 года.</p>
		</div>
		<div id="libraries">
			<h2>2. Организация библиотек</h2>
			<div id="libraries_connection">
				<h3>2.1. Подключение файла библиотеки</h3>
				<p>Один из самых важных навыков в программировании - грамотное разделение кода программ на относительно независимые группы функций - <i>библиотеки</i>. Библиотека может храниться в одном или нескольких файлах; случаются также ситуации, когда несколько библиотек хранятся в одном документе для ускорения загрузки.</p>
				<p>Библиотека атомарна: достаточно в одном месте программы написать код ее подключения, и ниже этого места можно пользоваться ее содержимым.</p>
				<p>Введем ряд правил, которых будем придерживаться на протяжении всего реферата. Все необходимые библиотеки будем хранить в одном каталоге - <b>lib</b>. Этот каталог находится в каталоге документов сервера (его имя всегда доступно через <b>getenv(“DOCUMENT_ROOT”)</b>) и для него запрещен просмотр через браузер. Запрета можно добиться при использовании сервера Apache, создав в каталоге файл <b>.htaccess</b> следующего содержания (листинг 2.1).</p>
				<h4>Листинг 2.1. Файл lib/.htaccess</h4>
				<code>deny from all</code>
				<p>Теперь нужно, чтобы при вызове</p>
				<code>require_once "library_name.php"</code>
				<p>происходил поиск этого файла в указанном каталоге. Для этого следует изменить внутреннюю переменную PHP с именем <b>include_path</b>, которая задается в файле <b>php.ini</b>.</p>
				<p>Поскольку изменять <b>php.ini</b> в большинстве случаем нельзя, в скрипте, которому требуется библиотека, воспользуемся функцией <b>ini_set()</b>:</p>
				<code># добавить путь поиска библиотек ini_set("include_path", <br>getenv("DOCUMENT_ROOT")."/lib");<br>
				#...<br>
				#теперь можно подключать: require_once “library_name.php";</code>
				<p>Лучше всего выделить код из листинга 2.2 в отдельный файл, который подключается в начале работы. Создадим файл <b>lib/config.php</b>.</p>
				<h4>Листинг 2.2. Файл lib/config.php</h4>
				<code>
					<?php<br>
					if (!defined("PATH_SEPARATOR"))<br>
					define("PATH_SEPARATOR", getenv("COMSPEC")? ";" : ":");<br>
					ini_set("include_path", <br>ini_get("include_path").PATH_SEPARATOR.dirname(__FILE__));<br>
					?>
				</code>
				<p>Теперь появилась возможность писать фрагменты такого вида:</p>
				<code>require_once getenv("DOCUMENT_ROOT")."/lib/config.php";<br>
					...<br>
					require_once “library_name.php";
				</code>
			</div>
			<div id="libraries_conflicts">
				<h3>2.2. Разрешение конфликтов имен</h3>
				<p>Пускай была написана функция <b>length()</b>, вычисляющую количество элементов массива, и используете ее в своей программе. Через некоторое время понадобилось подключить библиотеку стороннего разработчика, и выясняется, что в ней тоже есть функция <b>length()</b>, но уже для определения длины строки. Возникает конфликт имен.</p>
				<p>На ранних стадиях создания  PHP разработчики не использовали существующий сейчас стандарт и называли функции односложно и не всегда корректно отображая их суть: <b>current(), key(), sort(), range()</b> и т. д. По мере разработки языка число функций настолько выросло, что давать им подобные названия стало нецелесообразно. Возникла высокая вероятность отказа работы пользовательских программ из-за конфликта имен.</p>
				<p>Одно из временных решений - добавлять в имена функций некоторый префикс, отвечающий их назначению. Так появились <b>array_keys(), array_merge(), array_splice()</b> и т. д. В их именах применяется префикс <b>array_</b>, свидетельствующий о том, что речь идет о работе с массивами. Такой префикс гарантирует в определенной степени уникальность имени, зато сильно удлиняет название функции.</p>
				<p>Применение префикса обладает большим недостатком. Если понадобится его поменять, придется изменить в программе каждое имя функции и переменной.</p>
				<p>Существует решение этой проблемы. Вместо того чтобы использовать префиксы в именах функций, можно поместить все объекты программы в так называемое <i>пространство имен</i>.</p>
				<p>Пространство имен (<b>namespace</b>) - это имеющий имя фрагмент программы, содержащий в себе функции, переменные, константы и другие именованные сущности. Для получения "извне" доступа к идентификатору из некоторого пространства имен служит синтаксис:</p>
				<code>имяПространстваИмен::имяИдентификатора</code>
				<p>Если осуществляется работа внутри некоторого пространства имен, не обращаясь к другим, то нет необходимости явно его указывать: подразумевается, что вначале идентификаторы ищутся в текущем пространстве.</p>
				<p>Удобство такого способа в том, что он позволяет решить проблему именования идентификатора. Представим, что есть два пространства имен: <b>main</b> (основная программа) и <b>lib</b> (сторонняя библиотека). В обеих определена функция <b>length()</b>. При этом доступ к одной функции будет выглядеть как <b>lib::length()</b>, а к другой - <b>main::length()</b>. Причем для кода, который находится в пространстве имен main, префикс main:: можно не указывать.  Представим программу на "псевдоязыке", поддерживающем работу с пространствами имен (к таким языкам относятся C++, C#, Java и т.д.):</p>
				<code>namespace lib { function length($str) { ... }<br>
					}<br>
					namespace main { function length($arr) { ... }<br>
					...<br>
					echo length($a); # вызывается main::length() <br>
					echo lib::length($s); # вызывается lib::length()<br>
					}
				</code>
			</div>
			<div id="libraries_autoload">
				<h3>2.3. Автоматическая загрузка классов</h3>
				<p>Из предыдущих пунктов можно заметить, что прежде, чем использовать какой-то модуль, его необходимо подключить. Если библиотек много, их подключение может оказаться долгим и муторным процессом. В PHP существует средство, позволяющее загружать классы автоматически: как только программа пытается обратиться к несуществующему классу, вызывается функция <b>spl_autoload_register()</b>.</p>
				<p>Напишем функцию для загрузки классов <b>MyClass1</b> и <b>MyClass2</b> из файлов <b>MyClass1.php</b> и <b>MyClass2.php</b> соответственно:</p>
				<code>
					<?php<br>
					spl_autoload_register(function ($class_name) {<br>
					include $class_name . '.php';<br>
					});<br>
					$obj  = new MyClass1();<br>
					$obj2 = new MyClass2();<br>
					?>
				</code>
				<p>Функция <b>spl_autoload_register()</b> позволяет зарегистрировать необходимое количество автозагрузчиков для автоматической загрузки классов и интерфейсов, если они в настоящее время не определены.</p>
			</div>
			<div id="libraries_main_script">
				<h3>2.4. Главный файл скрипта</h3>
				<p>Обычно, при написании больших скриптов стараются разбить их на некоторое число независимых библиотек (модулей). Хорошим тоном считается перенос основного кода программы в библиотеки так, чтобы головной файл скрипта лишь подключал их и вызывал одну из функций оттуда. Это позволяет более удобно отлаживать программы.</p>
				<p>Например, если URI запроса выглядит как <b>/path/to/view.php</b>, файл <b>view.php</b> может содержать:</p>
				<code><?php<br>
					require_once "lib/config.php";<br>
					require_once "System/MainLib.php";<br>
					System_MainLib::doView();<br>
					?>
				</code>
				<p>Как видите, основная работа происходит в функции <b>System_MainLib::doView()</b>, а головной файл лишь занимается ее подключением.</p>
				<p>Чтобы выйти из глобальной области видимости, в PHP существуют функции. Таким образом, рекомендуется основной код программы размещать внутри функции, а к глобальным переменным иногда обращаться явным способом: либо через инструкцию <b>global</b>, либо через массив <b>$GLOBALS</b>.</p>
				<p>Однако создать функцию и тут же ее использовать - решение не очень элегантное. Во-первых, так не решается проблема констант, которые могут понадобиться главному файлу (определять константы при помощи <b>define()</b> в глобальной области видимости, опять же, нежелательно). Во-вторых, опять "засоряется" глобальная область видимости, но на этот раз не переменными, а функциями.</p>
				<p>Решение проблемы известно: следует заключить основной код программы в область видимости (листинг 2.4).</p>
				<h4>Листинг 2.4. Файл script.php</h4>
				<code><?php<br>
					class script {<br>
					# Основная функция программы. Запускается при старте скрипта.<br>
					static function main() {<br>
					$start = self::microtime(); <br>
					sleep(1);<br>
					echo "Параметр test: ".@$_REQUEST['test']; <br>
					$end = self::microtime();<br>
					echo "<hr>Программа работала ".sprintf("%.2f", $end-$start)." с";
					}
					#double microtime()
					#Возвращает текущее время в секундах в виде ДЕЙСТВИТЕЛЬНОГО
					#числа (с долями секунды). Заменяет стандартную microtime(),
					#возвращающую массив, с которым не очень удобно работать. 
					private static function microtime() {
					$t = explode(" ", microtime()); 
					return $t[0]+$t[1];
					}
					}
					if (!defined("DONT_CALL_MAIN")) script::main(); ?>
				</code>
			</div>
			<div id="libraries_interface">
				<h3>2.5. Интерфейс библиотеки</h3>
				<p>Интерфейс модуля - это то, как он "виден" извне. Иными словами, это набор функций, переменных и констант, доступных в подключающей библиотеку программе.</p>
				<p>Ранее функции помещались в области видимости, чтобы они сразу же были доступны внешним программам. Это не всегда желательно: ведь существуют вспомогательные и служебные функции для внутреннего использования.</p>
				<p>Чтобы исключить функцию или переменную из интерфейса библиотеки, нужно написать перед ее объявлением ключевое слово <b>private</b> (листинг 2.5). Слово <b>public</b>, наоборот, подчеркивает, что идентификатор общедоступен, "открыт" (режим по умолчанию).</p>
				<h4>Листинг 2.5. Файл t_private.php</h4>
				<code><?php<br>
					class test {<br>
					#Скрытая переменная. <br>
					private static $v = 10;<br>
					#Общедоступная функция. <br>
					public static function pub() {<br>
					echo "public (v=".self::$v.")< br>"; <br>
					self::pri("вызов изнутри класса");<br>
					}<br>
					#Скрытая функция<br>
					private static function pri($from) { <br>
					echo "private $from< br>";<br>
					}<br>
					}<br>
					test::pub();<br>
					test::pri("снаружи");<br>
					?>
				</code>
				<p>Результат работы данного скрипта выглядит так:</p>
				<code>Public (v=10)</code>
				<p>private вызов изнутри класса</p>
				<code>Fatal error: Call to private method test::pri() from context '' in <br>c:\\savva\php\src\libraries\t_private.php on line 13</code>
				<p>Как видите, вызов функции <b>pri()</b> из функции <b>pub()</b> прошел штатно, а вызов из основной программы привел к ошибке.</p>
				<p>Рекомендуется объявлять при помощи <b>private</b> как можно больше идентификаторов, оставляя доступным лишь самое необходимое.</p>
			</div>
			<div id="libraries_inheritage">
				<h3>2.6. Наследование и расширение модулей</h3>
				<p>Предположим, есть некоторый модуль (возможно, написанный другим программистом) с некоторым интерфейсом. Существует задача добавить в этот модуль еще несколько функций, чтобы они были доступны наравне с имеющимися.</p>
				<p>В этом случае можно воспользоваться наследованием (листинг 2.6).</p>
				<h4>Листинг 2.6. Файл lib/MyFileFindExt.php</h4>
				<code><?php<br>
					require_once "MyFileFind.php";<br>
					class MyFileFindExt extends MyFileFind {<br>
					# Переопределяется имеющаяся функция. <br>
					public function readdir($dir) {<br>
					echo "readdir($dir) called\n";<br>
					# Вызывается исходная функция из MyFileFind. <br>
					return parent::readdir($dir);<br>
					}<br>
					# Новая функция.<br>
					public function readcurdir() { <br>
					return self::readdir(".");<br>
					}<br>
					}<br>
					# Печатается диагностическое сообщение (для примера). <br>
					echo "File ".__FILE__." loaded.\n";<br>
					?>
				</code>
				<p>При указании строки "<b>class MyFileFindExt extends MyFileFind</b>", создается класс, содержащий все те же функции, переменные и константы, что и <b>MyFileFind</b>, и еще несколько. Класс, от которого происходит наследование (<b>MyFileFind</b>), называется базовым, а новый класс (<b>MyFileFindExt</b>) - производным.</p>
			</div>
		</div>
		<div id="classes_and_hides">
			<h2>3. Классы и сокрытие данных</h2>
			<div id="classes_and_hides_datatype">
				<h3>3.1. Класс как тип данных</h3>
				<p>Ключевым понятием ООП является <i>класс</i>. Класс можно рассматривать как тип некоторой переменной. Переменная класса (далее: объект класса) обычно имеет набор свойств (значений различных типов) и операций, которые могут быть с ним проведены. Свойства и методы класса часто называют его членами.</p>
				<p>Например, можно рассмотреть тип <b>int</b> как класс. Тогда переменная этого "класса" будет обладать одним свойством (ее целым значением), а также набором методов (сложение, вычитание, инкремент и т. д.). При этом методы выглядят как арифметические операторы +, -, ++ и т. д.</p>
				<p>В языке C++ можно было бы объявить новый тип <b>Int</b> именно таким образом путем перегрузки. Однако в PHP дело обстоит немного сложнее: у программиста нет прав для переопределения стандартных операций (сложение, вычитание и т. д.) для объектов. Например, если бы возникла необходимость добавить в язык комплексные числа, в C++ это можно было сделать без особых затруднений, однако в PHP такое добавление не удастся.</p>
				<p>Альтернативное решение состоит в том, чтобы везде вместо + и других операций использовать вызовы соответствующих функций, например, <b>add()</b>, которые бы являлись методами класса.</p>
				<p>Подход к созданию классов, применяемый в объектно-ориентированных языках, называют инкапсуляцией. Данные, принадлежащие классу, сохраняются в его свойствах, доступ к которым тщательно ограничивается и предоставляется в основном при помощи специальных методов.</p>
			</div>
			<div id="classes_and_hides_creating">
				<h3>3.2. Создание нового класса</h3>
				<p>Новый класс в программе описывается при помощи ключевого слова <b>class</b>. Внутри класса могут располагаться его свойства (переменные класса) и методы (функции-члены класса).</p>
				<p>Опишем класс с именем <b>Math_Complex</b>, объекты которого будут хранить комплексные числа (листинг 3.1). Этот класс пока поддерживает только сложение и вычитание.</p>
				<h4>Листинг 3.1. Файл lib/Math/Complex.php</h4>
				<code><?php <br>
					class Math_Complex {<br>
					//Свойства: действительная и мнимая части.<br> 
					public $re, $im;<br>
					//Метод: добавить число к текущему значению. Число задается<br>
					//своей действительной и мнимой частью.<br>
					function add($re, $im) {<br>
					$this->re += $re;<br>
					$this->im += $im;<br>
					} } ?>	
				</code>
				<p>Файл, приведенный в листинге 3.1, при своем включении не выполняет никаких действий. Его задача - добавить в программу новый класс с именем <b>Math_Complex</b>. Можно заметить, что в этом отношении описание класса очень похоже на описание библиотеки: один файл - один класс.</p>
				<p>Однако есть одно большое отличие. Если бы <b>Math_Complex</b> был описан как библиотека (а переменные <b>$re</b> и <b>$im</b> - как <b>static</b>-члены), в программе имелся бы единственный экземпляр пары переменных <b>$re</b> и <b>$im</b>, с которой работала бы функция <b>add()</b>. В то же время, описание класса позволяет в скрипте создавать несколько объектов-экземпляров данного класса, у каждого из которых будет своя собственная пара переменных (<b>$re, $im</b>). В этом отношении класс напоминает библиотеку, способную к "размножению".</p>
			</div>
			<div id="classes_and_hides_work">
				<h3>3.3. Работа с классами</h3>
				<p>Предположим, что в программе каким-то образом уже описан некоторый класс. Так как класс - это, по сути, тип данных, должен существовать некоторый механизм для создания переменных, хранящих значение этого типа.</p>
				<p>При создании переменных, имеющих пользовательский тип данных, применяется ключевое слово new, за которым следует имя класса:</p>
				<code>$obj = new Math_Complex;</code>
				<p>Теперь <b>$obj</b> хранит все данные класса - в частности, содержит внутри себя отдельные значения <b>$re</b> и <b>$im</b>.</p>
				<p>Каждый объект имеет свой собственный набор ассоциированных с ним свойств (значений, или переменных) и множество методов. Каждое свойство объекта доступно в программе по его имени. Можно присваивать значение свойству или получать его величину:</p>
				<code>//Создается новый объект класса Math_Complex. <br>
					$obj = new Math_Complex;<br>
					//Присваивает значение свойствам $re и $im объекта $obj. <br>
					$obj->re = 6;<br>
					$obj->im = 101;<br>
					//Выводит значение свойства re объекта $obj.<br>
					echo $obj->re;
				</code>
				<p>В PHP для вызова метода некоторого объекта используется оператор "стрелка" (листинг 3.2).</p>
				<h4>Листинг 3.2. Файл call.php</h4>
				<code><?php<br>
					//Подключение каталога библиотек в include_path. <br>
					require_once "lib/config.php";<br>
					//Загрузка класса.<br>
					require_once "Math/Complex.php";<br>
					//Создается новый объект класса Math_Complex. <br>
					$obj = new Math_Complex;<br>
					//Присваивается начальное значение свойствам. <br>
					$obj->re = 16.7;<br>
					$obj->im = 101;<br>
					//Вызов метода add()с параметрами (18.09, 303) объекта $obj. <br>
					$obj->add(18.09, 303);<br>
					//Выводится результат:<br>
					echo "({$obj->re}, {$obj->im})"; ?>
				</code>
				<p>Давайте посмотрим, что происходит, когда вызывается метод класса. Первым делом создается локальная переменная <b>$this</b>, которой присваивается то же значение, что было у <b>$obj</b>. То есть, в <b>$this</b> теперь хранится ссылка на объект, для которого вызывается метод. Далее PHP смотрит, какому классу принадлежит <b>$obj</b> (в данном случае это <b>Math_Complex</b>) и находит функцию-член: <b>Math_Complex::add()</b>. Функция вызывается, при этом <b>$this</b>, напомним, равен <b>$obj</b>. В итоге <b>add()</b> изменяет значения <b>$obj->re</b> и <b>$obj->im</b>.</p>
				<p>Как видно, вызов метода некоторого объекта автоматически предоставляет ему доступ к свойствам этого объекта посредством специальной переменной <b>$this</b>. При этом <b>$this</b> не нужно нигде объявлять явно, она появляется сама собой. Данная техника - ключевая особенность ООП.</p>
			</div>
			<div id="classes_and_hides_initializing">
				<h3>3.4. Инициализация и разрушение</h3>
				<p>Для корректного создания объекта недостаточно просто использовать оператор <b>new</b>: потом приходится еще инициализировать свойства объекта (<b>$re</b> и <b>$im</b>). В листинге 3.3 представлена реализация класса комплексных чисел с инициализацией.</p>
				<h4>Листинг 3.3. Файл lib/Math/Complex2.php</h4>
				<code><?php <br>
					class Math_Complex2 {<br>
					public $re, $im;<br>
					//Инициализация нового объекта. <br>
					function __construct($re, $im) {<br>
					$this->re = $re; $this->im = $im;<br>
					}<br>
					//Добавляет к текущему комплексному числу другое. function add(<br>Math_Complex2 $y) {<br>
					$this->re += $y->re;<br>
					$this->im += $y->im;<br>
					}<br>
					// Преобразует число в строку (например, для вывода). <br>
					function __toString() {<br>
					return "({$this->re}, {$this->im})";<br>
					} } ?>
				</code>
				<p>Метод <b>__construct()</b> - это конструктор класса. Он вызывается всегда, когда используется оператор <b>new</b> для объекта.</p>
				<p>В данном примере конструктор принимает два параметра: действительную и вещественную часть комплексного числа. Листинг 3.4 показывает применение данного класса.</p>
				<h4>Листинг 3.4. Файл construct.php</h4>
				<code><?php <br>
					require_once "lib/config.php"; <br>
					require_once "Math/Complex2.php"; <br>
					$a = new Math_Complex2(314, 101); <br>
					$a->add(new Math_Complex2(303, 6)); <br>
					echo $a;<br>
					?>
				</code>
				<p>Как и для обычных функций и методов, для конструкторов можно задавать параметры по умолчанию. Например, объявив его следующим образом:</p>
				<code>function __construct($re=0, $im=0) {<br>
					$this->re = $re;<br>
					$this->im = $im;<br>
					}
				</code>
				<p>По аналогии с конструкторами обычно рассматриваются <i>деструкторы</i>. Деструктор - специальный метод объекта, который вызывается при уничтожении этого объекта (например, после завершения программы). Деструкторы обычно выполняют служебную работу - закрывают файлы, записывают протоколы работы, разрывают соединения.</p>
				<p>В листинге 3.5 приведен класс с именем <b>File_Logger</b>, в котором объявляется деструктор. Нет необходимости заботиться о "ручном" вызове <b>close()</b> в программе - PHP выполняет "завершающие" действия самостоятельно.</p>
				<h4>Листинг 3.5. Файл lib/File/Logger.php</h4>
				<code><?php <br>
					class File_Logger {<br>
					public $f;	// открытый файл<br>
					public $name 	// имя журнала<br>
					public $lines = array(); <br>
					// накапливаемые строки <br>
					public $t;<br>
					//Создает новый файл журнала или открывает дозапись в конец<br>
					//существующего. Параметр $name - логическое имя журнала. <br>
					public function __construct($name, $fname) {<br>
					$this->name = $name;<br>
					$this->f = fopen($fname, "a+"); <br>
					$this->log("### __construct() called!");<br>
					}<br>
					//Гарантированно вызывается при уничтожении объекта.<br>
					//Закрывает файл журнала.<br>
					public function __destruct() { $this->log("### __destruct() called!");<br>
					//Вначале выводятся все накопленные данные. <br>
					fputs($this->f, join("", $this->lines));<br>
					//Затем закрывается файл.<br>
					fclose($this->f);<br>
					}<br>
					//Добавляет в журнал одну строку. Она не попадает в файл сразу же,<br>
					//а записывается в буфер и остается там до вызова __destruct(). public <br>function log($str) {<br>
					//Каждая строка предваряется текущей датой и именем журнала.<br>
					$prefix = "[".date("Y-m-d_h:i:s ")."{$this->name}] "; <br>
					$str = preg_replace('/^/m', <br>
					$prefix, rtrim($str)); // Сохраняем строку.<br>
					$this->lines[] = $str."\n";<br>
					} } ?>
				</code>
				<p>Рассмотрим, как может выглядеть использование данного класса (листинг 3.6).</p>
				<h4>Листинг 3.6. Файл destr.php</h4>
				<code>
					<?php ##<br>
					require_once "lib/config.php";<br>
					require_once "File/Logger.php"; <br>
					for ($n=0; $n<10; $n++) {<br>
					$logger = new File_Logger("test$n", "test.log"); <br>
					$logger->log("Hello!");<br>
					}<br>
					exit();<br>
					?>
				</code>
			</div>
			<div id="classes_and_hides_access">
				<h3>3.5. Права доступа к членам класса</h3>
				<p>До сих пор свойства и методы класса объявлялись без учета того, должны ли они быть доступны в программе, или же используются только для внутренних целей.</p>
				<p>В PHP существуют три модификатора ограничения доступа: <b>public</b>, <b>protected</b> и <b>private</b>. Их можно указывать перед описанием метода или свойства класса.</p>
				<ul style="list-style-type: disc;">
					<li><b>Public</b>: открытый доступ</li>
					<p>Члены класса, отмеченные ключевым словом public ("публичный", "открытый"), доступны для использования вне класса (например, из вызывающей программы). Пример:</p>
					<code>class Hotel { public $exit;<br>
						public function escape() {<br>
						echo "Let's go through the {$this->exit}!";<br>
						}<br>
						}<br>
						$theLafayette = new Hotel();<br>
						$theLafayette->exit = "main wet wall"; // допустимо<br>
						$theLafayette->escape(); // допустимо
					</code>
					<li><b>private</b>: доступ только из методов класса</li>
					<p>С использованием ключевого слова <b>private</b> ("личный", "закрытый") можно сделать члены касса "невидимыми" для вызывающей программы, будто бы их и нет. В тоже время, методы "своего" класса могут обращаться к ним без ограничений. Пример:</p>
					<code>class Hotel { private $exit;<br>
						public function escape() {<br>
						$this->findWayOut(); // допустимо <b></b>
						echo "Let's go through the {$this->exit}!"; // допустимо<br>
						}<br>
						public function lock() { $this->exit = null; } private function <br>findWayOut() {<br>
						$this->exit = "main wet wall"; // допустимо<br>
						}<br>
						}<br>
						$theLafayette = new Hotel(); $theLafayette->findWayOut(); <br>$theLafayette->escape(); $theLafayette->exit = "hotel doors";<br>
						//Ошибка! Доступ закрыт!<br>
						//допустимо<br>
						//Ошибка! Доступ закрыт!
					</code>
					<li><b>Protected</b>: доступ из методов производного класса</li>
					<p>Модификатор <b>protected</b> ("защищенный") с точки зрения вызывающей программы выглядит точно так же, как и <b>private</b>: он запрещает доступ к членам объекта извне. Однако по сравнению с <b>private</b> он позволяет обращаться к членам не только из "своих" методов, но также и из методов производных классов (если используется наследование).</p>
				</ul>
			</div>
		</div>
		<div id="inheritage_and_virtual_methods">
			<h2>4. Наследование и виртуальные методы</h2>
			<div id="inheritage_and_virtual_methods_dot">
				<h3>4.1. Расширение класса</h3>
				<p>При помощи механизма <i>наследования</i> можно создавать новые типы данных не "с нуля", а взяв за основу некоторый, уже существующий, класс, который в этом случае называют базовым (<b>base class</b>). Получившийся же класс носит имя производного (<b>derived class</b>).</p>
				<p>Наследование в ООП используется для нескольких различных целей:</p>
				<ul style="list-style-type: disc;">
					<li>добавление в существующий класс новых методов и свойств или замена уже существующих;</li>
					<li>наследование в целях классификации и обеспечения однотипности поведения различных классов.</li>
				</ul>
				<p>Дело в том, что новый, производный класс обладает теми же самыми "особенностями", что и базовый, и может использоваться везде вместо последнего. Например, рассмотрим базовый класс <i>Автомобиль</i> и производный от него - <i>БМВ</i>. Очевидно, что везде, где требуется объект типа <i>Автомобиль</i>, можно подставить и объект типа <i>БМВ</i> (но не наоборот). Создав еще несколько производных от <i>Автомобиля</i> классов (<i>Мерседес, Бентли, Газ</i> и т. д.), в ряде случаев можно работать с ними всеми однотипным образом, как с объектами типа <i>Автомобиль</i>, не вдаваясь в детали.</p>
				<p>Пусть есть некоторый класс <b>File_Logger</b> (см. п. 3) с определенными свойствами и методами. В листинге 4.1 приведен его код.</p>
				<h4>Листинг 4.1. Файл lib/File/Logger.php</h4>
				<code>public $lines = array(); <br>
					// накапливаемые строки <br>
					public $t;<br>
					public function __construct($name, $fname) { $this->name = $name;<br>
					$this->f = fopen($fname, "a+");<br>
					}<br>
					public function __destruct() { fputs($this->f, join("", $this->lines)); <br>fclose($this->f);<br>
					}<br>
					public function log($str) {<br>
					$prefix = "[".date("Y-m-d_h:i:s ")."{$this->name}] "; $str = <br>preg_replace('/^/m', $prefix, rtrim($str)); $this->lines[] = $str."\n";<br>
					} } ?>
				</code>
				<p>Допустим, что действия этого класса не удовлетворяют требованиям, например, он выполняет большинство необходимых функций, но не реализует некоторые другие. Создадим новый класс <b>File_Logger_Debug</b>, как бы "расширяющий" возможности класса <b>File_Logger</b>. Он будет добавлять ему несколько новых свойств и методов (листинг 4.2).</p>
				<h4>Листинг 4.2. Файл lib/File/Logger/Debug.php</h4>
				<code>
					<?php<br>
					//Вначале подключается "базовый" класс. <br>
					require_once "File/Logger.php";<br>
					//Класс, добавляющий в File_Logger новую функциональность. <br>
					class File_Logger_Debug extends File_Logger {<br>
					public function __construct($fname) {<br>
					parent::__construct(basename($fname), $fname);<br>
					}<br>
					public function debug($s, $level=0) { $stack = debug_backtrace();<br>
					$file = basename($stack[$level]['file']); $line = $stack[$level][‘line'];<br>
					$this->log("[at $file line $line] $s");<br>
					} } ?>
				</code>
				<p>Ключевое слово <b>extends</b> говорит о том, что создаваемый класс <b>File_Logger_Debug</b> является лишь "расширением" класса <b>File_Logger</b>, и не более того. То есть <b>File_Logger_Debug</b> содержит те же самые свойства и методы, что и <b>File_Logger</b>, но помимо них и еще некоторые дополнительные, "свои".</p>
				<p>Теперь “часть" <b>File_Logger</b> находится прямо внутри класса <b>File_Logger_Debug</b> и может быть легко доступна, наравне с методами и свойствами самого класса <b>File_Logger_Debug</b>.</p>
				<p>Итак, видно, что, действительно, класс <b>File_Logger_Debug</b> является воплощением идеи "расширение функциональности класса <b>File_Logger</b>".</p>
			</div>
			<div id="inheritage_and_virtual_methods_polymorfism">
				<h3>4.2. Полиморфизм</h3>
				<p><i>Полиморфизм</i> (многоформенность) - одно из интересных следствий идеи наследования. Полиморфность - это способность объекта использовать методы не своего собственного класса, а производного, даже если на момент определения базового класса производный еще не существует.</p>
				<p>С использованием полиморфизма можно писать классы-шаблоны, реализующие некоторую функциональность лишь частично, и лишь в той степени, в которой она им самим "известна". В дальнейшем, создавая производные классы, можно уточнить остальную часть кода, специфичную для приложения.</p>
				<p>Пусть где в программе имеется класс <b>Shape</b>, соответствующий некоторой геометрической фигуре. Программа должна уметь выполнять два действия:</p>
				<ul style="list-style-type: disc;">
					<li>перемещать фигуры при вызове метода <b>moveBy()</b>;</li>
					<li>увеличивать или уменьшать размер фигуры с вызовом метода <b>resizeBy()</b>.</li>
				</ul>
				<p>Каждому действию соответствует один метод, в данном случае - это методы <b>moveBy()</b> и <b>resizeBy()</b>. Также каждая фигура обладает такими свойствами:</p>
				<ul style="list-style-type: disc;">
					<li>координатами (свойства <b>$x, $y</b>);</li>
					<li>текущим масштабом (<b>$scale</b>).</li>
				</ul>
				<p>В листинге 4.3 показано определение базового класса <b>Shape</b>, удовлетворяющее описанным выше условиям.</p>
				<h4>Листинг 4.3. Файл shapes/Shape.php</h4>
				<code>
					<?php <br>
					class Shape {<br>
					private $x=0, $y=0, $scale=1.0;<br>
					//Конструктор класса. Отображает фигуру на экране. <br>
					public function __construct() {<br>
					$this->show();<br>
					}<br>
					//Деструктор класса. Стирает фигуру с экрана. <br>
					public function __destruct() {<br>
					$this->hide();<br>
					}<br>
					public final function moveBy($dx, $dy) {<br>
					$this->hide();<br>
					$this->x += $dx; $this->y += $dy;<br>
					$this->show();<br>
					}<br>
					//Изменить масштаб отображения фигуры. <br>
					public final function resizeBy($coef) {<br>
					$this->hide(); $this->scale *= $coef; $this->show();<br>
					}<br>
					//Методы возвращают координаты центра и масштаб.<br>
					public final function getCoord() { return array($this->x, $this->y); } <br>public final function getScale() { return $this->scale; }<br>
					protected function hide() {<br>
					die(“действие неизвестно");<br>
					}<br>
					protected function show() {<br>
					die("действие неизвестно");<br>
					} } ?>
				</code>
				<p>Для гарантии того, что все геометрические фигуры будут вести себя одинаково, объявляются публичные методы финальными (<b>final</b>). Таким образом, их уже нельзя будет переопределить в производных классах, а значит, фигуры не смогут "отойти от принятых канонов".</p>
				<p>При описании класса <b>Shape</b> не делается никаких предположений о типе фигуры. Чтобы стереть и нарисовать еще неизвестную фигуру используются виртуальные методы.</p>
				<p>Виртуальным называют метод, который может переопределяться в производном классе. А в этом случае функции <b>show()</b> и <b>hide()</b> являются виртуальными, и даже более того: в классе <b>Shape</b> неизвестно, как они должны быть "устроены", потому что все еще нет информации о типе фигуры. Таким образом, вызывать виртуальные методы <b>Shape</b> бессмысленно, что подчеркивается запуском встроенной функции <b>die()</b> в них (см. листинг 4.3).</p>
				<p>Раз в базовом классе Shape виртуальные методы <b>show()</b> и <b>hide()</b> "вырождены" и являются абстрактными, обязательно нужно переопределить их в производном классе (листинг 4.4).</p>
				<h4>Листинг 4.4. Файл shapes/Circle.php</h4>
				<code><?php <br>
					require_once "ShapeA.php";<br>
					class Circle extends Shape {<br>
					//Радиус круга в масштабе 1:1. <br>
					private $radius;<br>
					//Создается новый объект-круг с указанием радиуса. <br>
					public function __construct($radius=100) {<br>
					$this->radius = $radius; parent::__construct();<br>
					}<br>
					//Отображает круг на экране.<br>
					public function show() {<br>
					list ($x, $y) = $this->getCoord();<br>
					$radius = $this->radius * $this->getScale();<br>
					// *Код прорисовки круга* ($x, $y, $radius). echo "Рисуется круг: ($x, $y, <br>$radius)< br>";<br>
					}<br>
					// Стирает фигуру с экрана. public function hide() {<br>
					list ($x, $y) = $this->getCoord();<br>
					$radius = $this->radius * $this->getScale();<br>
					// *Код стирания круга* ($x, $y, $radius). echo "Стирается круг: ($x, $y, <br>$radius)< br>";<br>
					} } ?>
				</code>
				<p>Рассмотрим класс из листинга 4.4 подробнее.</p>
				<p>Любой объект-круг является также и объектом-фигурой, а потому должен наследовать методы и свойства класса <b>Shape</b>. Поэтому код базового класса <b>Shape</b> подключается в самом начале файла, а также объявляется <b>Circle</b> производный класс от <b>Shape</b>.</p>
				<p>У круга, помимо свойств, присущих фигуре, есть и свои собственные данные: это его радиус. Создается свойство <b>$radius</b>, в котором он будет храниться. Чтобы подчеркнуть, что радиус - свойство сугубо служебное и не может быть доступно извне, оно объявляется как закрытое (<b>private</b>).</p>
				<p>Круг имеет свой собственный конструктор, который вызывается в момент создания объекта. При создании указывается радиус круга. Фактически у каждого типа фигуры будут свои собственные конструкторы с различающимися списками параметров. Конструктор обычно не наследуется.</p>
				<p>Обязательно должен быть вызван конструктор базового класса Shape, в противном случае фигура не будет проинициализирована! Это делается явным образом: <b>parent::__construct()</b>.</p>
				<p>Главное преимущество, которое дает наследование и полиморфизм, - это несравненная легкость создания новых классов, ведущих себя сходным образом с уже существующими. Добавить в программу новую геометрическую фигуру (например, квадрат) крайне просто: достаточно лишь написать ее класс, сделав его производным от <b>Shape</b>. После этого любая программа, которая могла работать с кругами, начнет работать и с квадратами. Единственное изменение, которое придется внести в код, - это создание объекта-квадрата.</p>
				<p>Дадим определения терминам "абстрактный класс" и "абстрактный метод”.</p>
				<p>Абстрактный метод нельзя вызвать, если он не был переопределен в производном классе. Собственно, написанием функции <b>Shape::show()</b> и помещением в нее вызова <b>die()</b>, гарантируется, что она обязательно будет переопределена в производном классе.</p>
				<p>Объект абстрактного класса невозможно создать.</p>
				<p>Любой класс, содержащий хотя бы один абстрактный метод, сам является абстрактным.</p>
				<p>Специально для того, чтобы автоматически учесть эти особенности, в объектноориентированных языках программирования Java и PHP введено ключевое слово - модификатор <b>abstract</b>. Можно объявить класс или метод как <b>abstract</b>, и тогда контроль за их некорректным использованием возьмет на себя сам PHP.</p>
				<p>Абстрактные классы можно использовать только для одной цели: создавать от них производные. В листинге 4.5 приведен все тот же самый класс Shape, но только теперь используется ключевое слово <b>abstract</b> там, где это необходимо по логике.</p>
				<h4>Листинг 4.5. Файл shapes/ShapeA.php</h4>
				<code>
					<?php <br>
					abstract class Shape {<br>
					private $x=0, $y=0, $scale=1.0; public function __construct() {<br>
					$this->show();<br>
					}<br>
					public function __destruct() { $this->hide();<br>
					}<br>
					public final function moveBy($dx, $dy) { $this->hide();<br>
					$this->x += $dx; $this->y += $dy; $this->show();<br>
					}<br>
					public final function resizeBy($coef) { $this->hide();<br>
					$this->scale *= $coef; $this->show();<br>
					}<br>
					public final function getCoord() { return array($this->x, $this->y); }<br> public final function getScale() { return $this->scale; }<br>
					// Абстрактные методы.<br>
					abstract protected function hide(); abstract protected function show();<br>
					} ?>
				</code>
				<p>Если случайно будет пропущено ключевое слово <b>abstract</b> в заголовке класса Shape, PHP напомнит об этом сообщением о фатальной ошибке:</p>
				<code>Fatal error: Class Shape contains 2 abstract methods and must therefore be declared abstract (Shape::hide, Shape::show)</code>
			</div>
			<div id="inheritage_and_virtual_methods_interfaces">
				<h3>4.3. Интерфейсы</h3>
				<p>Интерфейс (<b>interface</b>) представляет собой обычный абстрактный класс, но только в нем не может быть свойств, и не определены тела у методов. Фактически, некоторый интерфейс указывает лишь список методов, их аргументы и модификаторы доступа (обычно только <b>protected</b> и <b>public</b>). Допускается также описание констант внутри интерфейса (ключевое слово <b>const</b>).</p>
				<p>Класс, наследующий некоторый интерфейс, обязан содержать в себе определения всех методов, заявленных в интерфейсе. Если хотя бы один из методов не будет реализован, невозможно будет создать объект класса: возникнет ошибка.</p>
				<p>Главное достоинство заключается в том, что класс может реализовывать (наследовать) сразу несколько интерфейсов. Для "привязки" интерфейсов к классу используется ключевое слово <b>implements</b>:</p>
				<code>interface IWorldObject {<br>
					public function getCoord(); // тело не указывается!<br>
					}<br>
					interface IVehicle {<br>
					public function getNumWheels(); // возвращает число колес<br>
					}<br>
					class Zaporojets implements IVehicle, IWorldObject {<br>
					public function getCoord() { ... }<br>
					public function getNumWheels() { ... }<br>
					}
				</code>
				<p>Интерфейсы часто используются как средство классификации объектов в программе. Для каждого абстрактного типа объекта из предметной области создается собственный интерфейс, а затем, при описании новых классов, указывается, какие интерфейсы они наследуют - иными словами, как их можно классифицировать.</p>
			</div>
		</div>
		<div id="errors_and_exceptions">
			<h2>5. Обработка ошибок и исключения</h2>
			<div id="errors_and_exceptions_errors">
				<h3>5.1. Ошибки</h3>
				<p>Термин "ошибка" имеет три различных значения:</p>
				<ol>
					<li>Ошибочная ситуация - непосредственно факт наличия ошибки в программе.</li>
					<li>Внутреннее сообщение об ошибке ("внутренняя ошибка"), которую выдает PHP в ответ на различные неверные действия программы.</li>
					<li>Пользовательское сообщение об ошибке ("пользовательская ошибка"), к которой причисляются все сообщения или состояния, генерируемые и обрабатываемые самой программой.</li>
				</ol>
				<p>Далее под ошибкой будет подразумеваться некоторая информация о ней. В простейшем случае эта информация включает в себя текст диагностического сообщения, но могут также уточняться и дополнительные данные, например, номер строки и имя файла, где возникла ошибочная ситуация. Если в программе возникла ошибочная ситуация, необходимо принять решение, что же в этом случае делать. Код, который этим занимается называют кодом восстановления после ошибки, а запуск этого кода -  восстановлением после ошибки. Рассмотрим пример:</p>
				<code>$f = @fopen("spoon.txt", "r");<br>
					if (!$f) return;
				</code>
				<p>Здесь код восстановления - это инструкция <b>if</b>, которая явно обрабатывает ситуацию невозможности открытия файла. Обратите внимание, что оператор <b>@</b> используется перед <b>fopen()</b>, чтобы не получить диагностическое сообщение от самого PHP.</p>
				<p>Ошибки по своей "серьезности" можно подразделить на два больших класса:</p>
				<ol style="list-style-type: disc;">
					<li>серьезные ошибки с невозможностью автоматического восстановления. Например, если осуществляется попытка открыть несуществующий файл, то далее обязательно должны указать, что делать, если это не удастся: ведь записывать или считывать данные из неоткрытого файла нельзя;</li>
					<li>"несерьезные" (нефатальные) ошибки, восстановление после которых не требуется, например, предупреждения (warnings), уведомления (notices), а также отладочные сообщения (debug notices). Обычно в случае возникновения такого рода ошибочных ситуаций нет необходимости предпринимать что-то особенное и нестандартное, вполне достаточно просто сохранить где-нибудь информацию об ошибке (например, в файле журнала).</li>
				</ol>
			</div>
			<div id="errors_and_exceptions_exceptions">
				<h3>5.2. Исключения</h3>
				<p>Механизм обработки исключений - это технология, позволяющая писать код восстановления после серьезной ошибки в удобном для программиста виде. С применением исключений перехват и обработка ошибок, наиболее слабая часть в большинстве программных систем, значительно упрощается.</p>
				<p>Исключение - это некоторое сообщение об ошибке вида "серьезная". При своей генерации оно автоматически передается в участок программы, который лучше всего "осведомлен", что же следует предпринять в данной конкретной ситуации. Этот участок называется обработчиком исключения.</p>
				<p>Любое исключение в программе представляет собой объект некоторого класса, создаваемый, как обычно, оператором <b>new</b>. Этот объект может содержать различную информацию, например, текст диагностического сообщения, а также номер строки и имя файла, в которых произошла генерация исключения. Допустимо добавлять и любые другие параметры. Рассмотрим пример вызова обработчика (листинг 5.1).</p>
				<h4>Листинг 5.1. Файл simple.php</h4>
				<code>
					<?php<br>
					echo "Начало программы.< br>";<br>
					try {<br>
					// Код, в котором перехватываются исключения. echo "Все, что имеет начало…< br>";<br>
					//Генерируется исключение. throw new Exception("Hello!");<br>
					echo "...имеет и конец.< br>";<br>
					}catch (Exception $e) {<br>
					//Код обработчика.<br>
					echo " Исключение: {$e->getMessage()}< br>";<br>
					}<br>
					echo "Конец программы.< br>"; <br>
					?>
				</code>
				<p>В листинге 5.1 приведен пример базового синтаксиса конструкции <b>try...catch</b>, применяемой для работы с исключениями.</p>
				<p>Код обработчика исключения помещается в блок инструкции <b>catch</b> (в переводе с английского - "ловить").</p>
				<p>Блок <b>try</b> (в переводе с английского - "попытаться") используется для того, чтобы указать в программе область перехвата. Любые исключения, сгенерированные внутри нее (и только они), будут переданы соответствующему обработчику.</p>
				<p>Инструкция <b>throw</b> используется для генерации исключения. Любое исключение представляет собой обычный объект PHP, который создается в операторе <b>new</b>.</p>
				<p>Стоит обратить внимание на аргумент блока <b>catch</b>. В нем указано, в какую переменную должен быть записан "пойманный" объект-исключение перед запуском кода обработчика. Также обязательно задается тип исключения - имя класса. Обработчик будет вызван только для тех объектов-исключений, которые совместимы с указанным типом (например, для объектов данного типа).</p>
			</div>
		</div>
		<div id="Iterators_arrays">
			<h2>6. Итераторы, массивы</h2>
			<div id="Iterators_arrays_access">
				<h3>6.1. Неявный доступ к классам и методам</h3>
				<p>В сложных приложениях приходится встречаться с ситуациями, когда одно из имен (или список аргументов) хранится в некоторой переменной, и в программе нельзя явно указать ее значение. Такое имя метода, класса или даже список аргументов функции называют неявным.</p>
				<p>Листинг 6.1 иллюстрирует неявный вызов метода <b>add()</b> для объекта <b>$a</b> класса <b>Math_Complex2</b>.</p>
				<h4>Листинг 6.1. Файл impl_meth.php</h4>
				<code>
					<?php<br>
					require_once "lib/config.php";<br>
					require_once "Math/Complex2.php";<br>
					$addMethod = "add";<br>
					$a = new Math_Complex2(101, 303);<br>
					$b = new Math_Complex2(0, 6);<br>
					// Вызывается метод add() неявным способом.<br>
					call_user_func(array(&$a, $addMethod), $b);<br>
					echo $a;<br>
					?>
				</code>
				<p>Для того чтобы передать некоторому методу аргументы, хранящиеся в том или ином списке, в PHP существует всего одно средство - функция <b>call_user_func_array()</b>. Она принимает два параметра: первый - это имя функции, а второй - массив, хранящий ее аргументы.</p>
				<p>Вот как может выглядеть вызов функции <b>test()</b>, аргументы которой хранятся в массиве:</p>
				<code>
					$args = array(101, 6);<br>
					$result = call_user_func_array("test", $args);
				</code>
				<p>А так вызывается метод <b>test()</b> некоторого объекта <b>$obj</b>:</p>
				<code>$result = call_user_func_array(array(&$obj, "test"), $args);</code>
				<p>Для вызова статического метода вместо объекта необходимо указать строковое имя класса:</p>
				<code>$result = call_user_func_array(array("ClassName", "test"), $args);</code>
				<p>Инстанциирование (instantiate) - это термин ООП, который означает "создание объекта некоторого класса". Инстанциировать класс - то же самое, что создать экземпляр (объект) этого класса.</p>
				<p>Перейдем к вопросу о том, как создать объект некоторого класса, если имя этого класса задано неявно, например, содержится в переменной. Листинг 6.2 показывает, как поступать в таком случае.</p>
				<h4>Листинг 6.2. Файл inst.php</h4>
				<code><?php <br>
					require_once "lib/config.php";<br>
					require_once "Math/Complex2.php";<br>
					//Пусть имя класса хранится в переменной $className. $className = <br>"Math_Complex2";<br>
					//Создается новый объект.<br>
					$obj = new $className(6, 1); echo "Созданный объект: $obj"; ?><br>
				</code>
			</div>
			<div id="Iterators_arrays_iterators">
				<h3>6.2. Итераторы</h3>
				<p>Итератор - это объект, класс которого реализует встроенный в PHP интерфейс <b>Iterator</b>. Он позволяет программе решать, какие значения необходимо подставлять в переменные инструкции <b>foreach</b> при ее работе и в каком порядке это делать.</p>
				<p>Любой объект, который хочет переопределить стандартное поведение инструкции <b>foreach</b>, должен реализовывать встроенный в PHP интерфейс <b>IteratorAggregate</b>. Интерфейс определяет единственный метод - <b>getIterator()</b>, который должен создать объект-итератор.</p>
				<p>В дальнейшем все решения о том, какие значения участвуют в переборе и в каком порядке их необходимо возвращать, принимает уже итератор.</p>
			</div>
			<div id="Iterators_arrays_virtual_methods">
				<h3>6.3. Виртуальные массивы</h3>
				<p>PHP позволяет создавать объекты, доступ к которым производится в соответствии с синтаксисом управления массивами PHP. Иными словами, можно использовать оператор <b>[]</b> для переменной-объекта, как будто работаете с обычным ассоциативным массивом. При этом возможно применение и обычного оператора <b>-></b> для доступа к свойствам и методам объекта.</p>
				<p>Если нужно указать интерпретатору, что к объекту некоторого класса возможно обращение, как к массиву, то придется использовать встроенный в PHP интерфейс <b>ArrayAccess</b> при описании соответствующего класса. Кроме того, необходимо определить тела методов, описанных в этом интерфейсе</p>
				<p>Рассмотрим пример использования интерфейса <b>ArrayAccess</b> (листинг 6.3).</p>
				<h4>Листинг 6.3. Файл array.php</h4>
				<code>
					<?php<br>
					class InsensitiveArray implements ArrayAccess {<br>
					//Здесь будет храниться массив элементов в нижнем регистре. private $a = <br>array();<br>
					//Возвращает true, если элемент $offset существует. public function <br>offsetExists($offset) {<br>
					$offset = strtolower($offset); // переводим в нижний регистр $this-><br>log("offsetExists('$offset')");<br>
					return isset($this->a[$offset]);<br>
					}<br>
					//Возвращает элемент по его ключу.<br>
					public function offsetGet($offset) { $offset = strtolower($offset); $this-><br>log("offsetGet('$offset')"); return $this->a[$offset];<br>
					}<br>
					//Устанавливает новое значение элемента по его ключу. public function <br>offsetSet($offset, $data) {<br>
					$offset = strtolower($offset); $this->log("offsetSet('$offset', <br>'$data')"); $this->a[$offset] = $data;<br>
					}<br>
					//Удаляет элемент с указанным ключом.<br>
					public function offsetUnset($offset) { $offset = strtolower($offset); <br>$this->log("offsetUnset('$offset')"); unset($this->array[$offset]);<br>
					}<br>
					// Служебная функция для демонстрации возможностей. public function<br> log($str) {<br>
					echo "$str< br>";<br>
					}<br>
					}<br>
					// Проверка.<br>
					$a = new InsensitiveArray();<br>
					$a->log("## Устанавливаются значения (оператор =)."); $a['php'] = 'There <br>is more than one way to do it.';<br>
					$a['pHp'] = 'Это значение должно переписаться поверх предыдущего.'; $a-><br>log("## Получаем значение элемента (оператор [])."); $a->log("< b><br>значение:</ b> '{$a['PHP']}'");<br>
					$a->log("## Проверяется существование элемента (оператор isset())."); $a-><br>log("< b>exists:</ b> ".(isset($a['Php'])? "true" : <br>"false")); $a->log("## Уничтожается элемент (оператор unset())."); <br>unset($a['phP']);<br>
					?>
				</code>
				<p>Результат работы данного кода выглядит примерно так:</p>
				<code>
					##Устанавливаются значения (оператор =). offsetSet('php', 'There is more than one way to do it.')<br>
					offsetSet('php', 'Это значение должно переписаться поверх предыдущего.')<br>
					##Получается значение элемента (оператор []).<br>
					offsetGet('php')<br>
					значение: 'Это значение должно переписаться поверх предыдущего.' ## <br
					>Проверяется существование элемента (оператор isset()). <br>offsetExists('php')<br>
					exists: true<br>
					## Уничтожается элемент (оператор unset()). offsetUnset('php')
				</code>
			</div>
		</div>
		<div id="Conclusion">
			<h2>7. Заключение</h2>
			<p>В этой работе было рассмотрено применение методологии ООП в скриптовом языке PHP. Было показано как работать с библиотеками, использовать классы и наследовать их, понятие полиморфизма, обработку ошибок и исключений, итераторы и виртуальные методы. Все сведения были подкреплены примерами кода, чтобы нагляднее демонстрировать предмет обсуждения. На текущий момент ООП - самая популярная парадигма в программировании и разработчику важно знать ее особенности и уметь её применять.</p>
		</div>
		<div id="Literature">
			<h2>8. Список использованной литературы</h2>
			<ol>
				<li>Wikipedia. PHP [Электронный ресурс]: свободная энциклопедия - /Wikipedia. - Электронные данные. Режим доступа: URL.:<a href="https://ru.wikipedia.org/wiki/PHP#Объектно-ориентированное_программирование"> https://ru.wikipedia.org/wiki/PHP#Объектно-ориентированное_программирование</a>, свободный - (дата обращения 25.11.2021)</li>
				<li>Wikipedia. Объектно-ориентированное программирование [Электронный ресурс]: свободная энциклопедия - /Wikipedia. - Электронные данные. Режим доступа: URL.: <a href="https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование">https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование#Производительность_объектных_программ</a>, свободный - (дата обращения 25.11.2021)</li>
				<li>Tiobe. TIOBE Index for November 2021 [Электронный ресурс]: the software quality company - / Tiobe. - Электронные данные. Режим доступа: URL.: <a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>, свободный - (дата обращения 25.11.2021)</li>
				<li>Php.net. Руководство по PHP [Электронный ресурс]: php.net - / Php.net. - Электронные данные. Режим доступа: URL.:<a href="https://www.php.net/manual/ru/">https://www.php.net/manual/ru/</a>, свободный - (дата обращения 24.11.2021)</li>
				<li>Кузнецов М., Симдянов И. Самоучитель PHP 7. — 2-е изд.. — СПб., 2018. — С. 448.</li>
				<li>Котеров, Д.В. PHP5 / Д.В. Котеров, А.Ф. Костарев. - 2-е изд., перераб. и доп. - СПб.: БХВ-Петербург, 2011. - 1104 с.: ил. - (В подлиннике)</li>
			</ol>
		</div>
	</div>
	<script src="scripts.js"></script>
	<footer style="border-top: solid 1px black;">
	    <ol>
	      <li id="top10"><a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
	    </ol>
  	</footer>
</body>
</html>