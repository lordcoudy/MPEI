СПО

Ян Белецкий - Энциклопедия языка Си
П.Абель - Яззык ассемблера для IBM PC и программирования

_____________________________________________________

Основной вопрос: регистры процессора i8086. 

Вы должны хорошо ориентироваться в них, их предназначении и особенностях работы с ними. Также, поскольку Вы уже достаточно долго слушаете курс СПО, Вас не должны смущать вопросы типа: "Каков формат машинного кода команды?", "Что такое префикс программного сегмента?", "Как адресуется память?" и прочие основополагающие термины и понятия.

20 разрядов у шины адреса из 2-х 16 разрядных компонент: сегмента и смещения А000:0000h
Чтобы вычислить адрес нужно сегмент умножить на 16 (сдвиг влево на 4 двоичных разряда) и сложить со смещением:
1234:5678h - адрес: (1234h<<4) + 5678h = 12340h + 5678h = 179B8h
сегмент - номер параграфа (из 4000; 16 байт из 64кбайт)
смещение для движения от точки отсчета (сегмента) к нужному байту

Сегменты находятся в нескольких сегментных регистрах:
cs - сегмент кода (для адресации к кодам)
ds - сегмент данных (для адресации к ячейке памяти)
ss - сегмент стека

всего 14 регистров

Регистры процессора 8086 16 разрядные
2 типа регистров: общего назначения и специального назначения

РОН используются на усмотрение программиста, РСН необходимы для корректной работы процессора

К РОН относятся: 
AX (AH, AL) - аккумулятор (буфер),
BX (BH, BL) - база (можно использовать как адрес при косвенной адресации к памяти,
CX (CH, CL) - счетчик (нужен для задания количество повторов в циклах), 
DX (DH, DL) - регистр данных (расширение аккумулятора до 32 разрядов, адрес порта при косвенной адресации к портам ввода/вывода)
SI - индекс источника (косвенная адресация к памяти, в строковых командах пара DS:SI содержит адрес источника данных)
DI - индекс приемника (косвенная адресация к памяти, пара ES:DI содержит адрес приемника данных)

К РСН относятся:
BP - указатель базы в стеке (Роль смещения при косвенной адресации к стеку, компиляторы ЯВУ используют его для организации стековых кадров процедур)
SP - указатель стека (пара SS:SP содержит адрес последней занятой ячеки стека, работает автоматически) (при пуш уменьшается на 2, потому что в стек заносятся 2-байтовые слова)
IP - указатель команды (нельзя прочитать или изменить в явном виде, пара CS:IP содержит адрес команды, исполняемой процессором, после выполнения команды указатель увеличивается на длину команды)
Flags - регистр флагов (нельзя прочитать или изменить в явном виде, но отдельные флаги могут быть проанализированы в командах условных переходов, а также модифицированы) (можно хранить в стеке и бэкапить PUSHF / POPF)

Флаги:
OF (Переполнение)
Указывает на переполнение старшего бита при арифметических командах.
DF (Направление, есл 0 в сторону увеличения адресов)
Обозначает левое или правое направление пересылки или сравнения строковых данных.
IF (Прерывание)
Указывает на возможность внешних прерываний.
TF (Пошаговый режим, трассировки)
Обеспечивает возможность работы процессора в пошаговом режиме.
SF (Знак)
Содержит результирующий знак после арифметических операций (0 - плюс, 1- минус).
ZF (Ноль)
Показывает результат арифметических операций и операций сравнения (0 - ненулевой, 1 - нулевой результат).
AF (Внешний перенос)
Содержит перенос из 3-го бита для 8-битовых данных, используется для специальных арифметических операций.
PF (Контроль четности, паритета)
Если младшие 8 битов содержат четное число единиц, то значение флага равно 1, в противном случае - 0.
CF (Перенос)
Содержит перенос из старшего бита после арифметических операций, а также последний бит при сдвигах или циклических сдвигах.

Сегментные регистры:
CS - сегмент кода (содержит сегментную часть адреса текущей команды)
SS - сегмент стека (содержит сегментную часть адресов в стеке при косвенной адресации с использование BP, вершина стека - SS:SP)
DS - сегмент данных (содержит сегментную часть адреса, используемую при прямом или косвенном обращении к даным)
ES - дополнительный сегмент (может укказываться в явном виде в качестве сегментной части адреса при обращении к данным)

Виды адресации:
Регистровая - операнд находится в регистре, который указан в команде
Непосредственная - операнд является числом, непосредственно указанным в команде
Прямая - операнд находится в памяти, адрес ячейки указан в явном виде в команде (адрес пишется в квадратных скобках)
Косвенная - операнд находится в ячейке памяти, адрес ячейки содержится в регистре, указанном в команде
Стековая - операнд заносится в стек или извлекается и вершины стека. Адрес задан в паре SS:SP

Виды косвенной адресации:
Базовая - в регистре указывается база, адрес образуется сложением базы и константы
Индексная - начало структуры данных задется константой, смещение вычисляется как сумма это константы и индекса, задаваемого в регистре
Базово-индексная - В регистре указываетсяя база (BX or BP), адрес образуется сложением этой базы, индекса, указываемого в другом регистре (SI или DI), и, возможно, константы

При прямой и косвенной адресации к памяти в качестве сегментной части используется содеримое регистра DS
При косвенной адресации с использованием BP идет обращение к стек, и сегментная часть берется из SS

PSP - префикс програмного сегмента

Лучше пока не трогать сегментные регистры и РСН



директивы:
db - define byte
dw - define word (2 bytes)
dd - define double (4 bytes)
dq - define quad (8 bytes)
dt - define ten (10 bytes)

если db, то можно записать стоку символов

db ? - значение не важно / не определено (заполнено 0)

директива N dup(M) - заполнение области памяти M значением N раз

любая метка имеет значение, и это значение - её адрес или её смещение


директивы процесса компиляции:
	MASM - по умолчанию
	ideal - улчшенный

STRUC - определяет структуру области памяти

Опкод		Значение(переход,если...)							Условие
JA			Jump if above (X > Y)								CF=0 & ZF=0
JAE			Jump if above or equal (X >= Y)						CF=0
JB			Jump if below (X									CF=1
JBE			Jump if below or equal (X							CF=1 or ZF=1
JC			Jump if carry (cf=1)								CF=1
JCXZ		Jump if CX=0										регистр CX=0
JE 			Jump if equal (X = Y)	ZF=1
JG			Jump if greater (signed) (X > Y)					ZF=0 & SF=OF
JGE			Jump if greater or equal (signed) (X >= Y)			SF=OF
JL			Jump if less (signed) (X							SF != OF
JLE			Jump if less or equal (signed) (X					ZF=1 or SF!=OF
JMP			Безусловный переход									-
JNA			Jump if not above (X								CF=1 or ZF=1
JNAE		Jump if not above or equal (X						CF=1
JNB			Jump if not below (X >= Y)							CF=0
JNBE		Jump if not below or equal (X > Y)					CF=1 & ZF=0
JNC			Jump if not carry (cf=0)							CF=0
JNE			Jump if not equal (X != Y)							ZF=0
JNG			Jump if not greater (signed) (X						ZF=1 or SF!=OF
JNGE		Jump if not greater or equal (signed) (X			SF!=OF
JNL			Jump if not less (signed) (X >= Y)					SF=OF
JNLE		Jump if not less or equal (signed) (X > Y)			ZF=0 & SF=OF
JNO			Jump if not overflow (signed) (of=0)				OF=0
JNP			Jump if no parity (pf=0)							PF=0
JNS			Jump if not signed (signed) (sf=0)					SF=0
JNZ			Jump if not zero (X != Y)							ZF=0
JO			Jump if overflow (signed) (of=1)					OF=1
JP			Jump if parity (pf=1)								PF=1
JPE			Jump if parity even (								PF=1
JPO			Jump if parity odd									PF=0
JS			Jump if signed (signed)								SF=1
JZ			Jump if zero (X = Y)								ZF=1



Однако для 16-битных сегментов, чтобы указать на источник и место назначения, используются другие регистры: SI и DI.

MOVS — эта инструкция перемещает 1 byte, word или doubleword данных из одной ячейки памяти в другую;
LODS — эта инструкция загружается из памяти. Если операндом является значение типа byte, то оно загружается в регистр AL, если типа word — загружается в регистр AX, если типа doubleword — загружается в регистр EAX;
STOS — эта инструкция сохраняет данные из регистра (AL, AX или EAX) в память;
CMPS — эта инструкция сравнивает два элемента данных в памяти. Данные могут быть размера byte, word или doubleword;
SCAS — эта инструкция сравнивает содержимое регистра (AL, AX или EAX) с содержимым элемента, находящегося в памяти.

Префикс REP, если он установлен перед строковой инструкцией (например, REP MOVSB), вызывает повторение инструкции на основе счетчика, размещенного в регистре CX. REP выполняет инструкцию, уменьшает CX на 1 и проверяет, равен ли CX нулю. Он повторяет обработку инструкций, пока CX не станет равным нулю.

Флаг направления (DF) определяет направление операции:

   Используйте CLD (англ. «Clear Direction Flag» = «Сбросить флаг направления», DF = 0), чтобы выполнить операцию слева направо.

   Используйте STD (англ. «Set Direction Flag» = «Установить флаг направления», DF = 1), чтобы выполнить операцию справа налево.

Префикс REP также имеет следующие вариации:

   REP — это безусловное повторение, которое повторяет операцию, пока CX не станет равным нулю.

   REPE или REPZ — это условное повторение, которое повторяет операцию до тех пор, пока нулевой флаг (ZF) указывает на равенство нулю результата (сам ZF установлен в единицу). Повторение останавливается, когда ZF указывает на неравенство результата нулю (ZF сброшен в ноль), или когда CX равен нулю.

   REPNE или REPNZ — это также условное повторение, которое повторяет операцию до тех пор, пока нулевой флаг указывает на неравенство нулю результата. Повторение останавливается, когда ZF указывает на равенство нулю результата, или когда CX уменьшается до нуля.
 


COM

У файла нет заголовка, нет структуры, невозможно задать точку входа, при загрузке код никаким преобразованиям не подвергается
Всегда выделяется 64к - полный сегмент
Все сегментные регистры настраиваются на начало сегмента
Первые 100h=256 байт отводятся под PSP
Код грузится со смещения 100h (после PSP) и стартует с самой первой команды (IP=100h)
Под стек отводится весь конец сегмента после кода
В стек при загрузке помещается 0

Модель TINY означает один единственный сегмент .CODE
ORG 100h - не причина, а следствие того, что код будет загружен по смещению 100h. 
Без ORG 100h смещение строки S, например, не соответствовало бы действительности.
Точка входа должна быть явно указана и должна быть по смещению 100h
Данные нужно размещать так, чтобы они не начали исполняться.

Недопустимы директивы SEG, недопустимы метки в качестве элементов массивов DD, т.к. нет заголовка, нет RLT и загрузчик не может подставить фактический адрес сегмента.
Компоновщик не может присоединить к файлу COM отладочную информацию.

При загрузке COM расходуется 64к памяти - для EXE выделяется столько, сколько нужно, не больше.
В COM ограничен объем доступной памяти, большой алгоритм не уместится - в EXE можно делать много сегментов, каждый до 64к.
Размер файла COM меньше за счет отсутствия заголовка - но место на диске выделяется кластерами, маленькие файлы все равно занимают целый кластер (кластер = 4к, 8к, 32к...).
Формат COM накладывает дополнительные ограничения: нельзя произвольно указать точку входа, использовать директивы SEG.

Чтобы один и тот же файл можно было скомпилировать и в COM,  и в EXE:
 Модель tiny
 Один сегмент
 Точка входа 100h
 Явно инициализировать DS, потому что при загрузке EXE для PSP выделяется ОТДЕЛЬНЫЙ сегмент:
 push cs
 pop ds
 Выход через функцию, годящуюся и для EXE, и для COM

Прерывания

Процессор поддерживает 256 различных источников прерываний
Прерывания делятся на:
внутренние
аппаратные (деление на 0, отладка...)
программные (int n)
внешние (они аппаратные)
немаскируемые (вход NMI ➔ int 2)
маскируемые (вход INTR, номер прерывания передает 			внешний контроллер прерываний)
Флаг IF влияет только на вход INTR и не влияет на другие прерывания (команды CLI / STI)

Таблица прерываний расположена по адресу 0000:0000 (в начале памяти) и содержит 256 двойных слов - дальних указателей на обработчики прерываний (вектора прерываний).
Когда случается прерывание номер N, из N-й ячейки таблицы извлекается вектор (младшее слово - смещение, старшее - сегментная часть адреса).
Текущие значения CS, IP и флагов сохраняются в стеке (6 байт).
Сбрасывается флаг IF (запрещаются внешние аппаратные прерывания).
Вектор загружается в CS:IP, начинает исполняться обработчик.

Аппаратные прерывания происходят всегда, они используют тот стек, на который сейчас указывают SS:SP
Если вы увеличили SP, а потом тут же уменьшили (освободили ячейку стека и снова ее заняли) - в это время могло произойти прерывание, и кратковременно освобожденная ячейка стека уже не содержит того, что в ней было.
При любых манипуляциях с настройкой SS:SP нужно запрещать прерывания.
Аналогично - при изменениях в таблице прерываний.

