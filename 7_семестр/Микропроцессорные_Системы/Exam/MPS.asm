=========== AVR ===========

SREG - регистр состояния (флаги) - 3Fh

BRBC bit, Loop ; переход к метке Loop если SREG.bit = 0
BRBS bit, Loop ; переход к метке Loop если SREG.bit = 1

RegIO - порт ввода-вывода (включая смешные регистры как SREG)

SBIC RegIO, bit - пропустить следующую команду, если RegIO.bit = 0
SBIS RegIO, bit - пропустить следующую команду, если RegIO.bit = 1
(эти команды работают только с первыми 32 портами (от 20h до 40h))

SBRC RG, bit - пропустить следующую команду, если RG.bit = 0
SBRS RG, bit - пропустить следующую команду, если RG.bit = 1
CPSE Rd, Rs - пропустить следующую команду, если Rd - Rs = 0 (не влияет на флаги)

++++++ Задачка: реализовать case (множ. выбор) ++++++

CP R1, R2			; R1-R2 и влияет на флаги
BRBS 1, metka_1		; 1 - флаг нуля
CP R1, R3
BRBS 1, metka_2
CP R1, R4
BRBS 1, metka_3

ИЛИ (лучше тем, что мы не разрушаем конвейер)

CPSE R1, R2
RJMP metka_1
RJMP case_1
metka_1:
CPSE R1, R3
RJMP metka_2
RJMP case_2
metka_2:
CPSE R1, R4
RJMP case_3

++++++ Задачка: найти минимальный элемент массива ++++++

Данные: размер массива пусть 20 элементов,
		адрес массива пусть 60h

Решение:
LDI R26, 0x60 		; загружаем в X адрес начала массива
LDI R27, 0			; загружаем в X адрес начала массива

LDI R18, 0x60+20	; загружаем в R18 адрес байта после конца массива

LD R16, X+			; загружаем первый элемент массива (считаем его min)

Loop:
	LD R17, X+			; загружаем очередной элемент массива
	CP R17, R16			; сравниваем с предполагаемым min
	BRBC 0, Next		; 0 – это флаг carry: если R17<R16, то
		MOV R16, R17	; carry=1 => переприсваиваем min
Next:
	CPSE R26, R18		; закончился ли массив? Если да, то пропускаем
	RJMP Loop			; этот прыжок на Loop

++++ Задачка: процедуры и функции с несколькими переменными (скопировать данные из внутр. памяти)++++

Данные: пусть во внутр. памяти насчиная с 60h лежат данные для копирования,
		объем данных 10 байт,
		и нужно их скопировать в во внутр. память по адресу 80h

Решение:
SJMP main

.ORG 0x0B
main:
	LDI R20, 0x60+20
	OUT SPL, R20
	
	; PUSH R26		; в функции мы эти регистры портим, поэтому сохриним на всякий случай
	; PUSH R28		; в функции мы эти регистры портим, поэтому сохриним на всякий случай
	; PUSH R16		; в функции мы эти регистры портим, поэтому сохриним на всякий случай
	
	LDI R1, 0x60
	PUSH R1
	LDI R1, 0x80
	PUSH R1
	LDI R1, 0x0A
	PUSH R1
	
	CALL prog
	
	;POP R16
	;POP R28
	;POP R26
Prog:
	POP R16
	POP R28
	POP R26
	
	PUSH R1
	
	Loop:
		LD R1, X+
		ST Y+, R1
		DEC R16
		BRBC 1, Loop
			POP R1
ret

ИЛИ

SJMP main

.ORG 0x0B
main:
	LDI R20, 0x60+20
	OUT SPL, R20
	
	LDI R26, 0x60
	LDI R28, 0x80
	LDI R16, 0x0A
	
	CALL prog
Prog:
	PUSH R26
	PUSH R28
	PUSH R16
	PUSH R1
	
	Loop:
		LD R1, X+
		ST Y+, R1
		DEC R16
		BRBC 1, Loop
			POP R1
			POP R16
			POP R28
			POP R26
ret
=========== i8051 ===========

PSW - регистр состояния (нет флага нуля)

JZ, JNZ - переход, если в Acc 0
например JZ Loop

JC, JNC - переход, если флаг carry поднят/сброшен
например JС Loop

JB, JNB - переход, если bit поднят/сброшен (а какой бит? вроде как любой)
например JB bit, Loop

CJNE - сравнение двух операндов и прыжок, если !=
DJNZ - декремент операнда и прыжок, если != 0