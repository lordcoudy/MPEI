rjmp main			; вектор сброса
rjmp couse			; вектор обработчика прерывания INT0
nop 		
nop
nop
rjmp full			; вектор обработчика прерывания переполнения таймера 0
nop
nop
nop
nop
nop
main:
ldi R16, 0			; R16 считает число событий
ldi R17, 16			; R17 число полных циклов таймера

ldi R20, 0x60+32	; настраиваем стек в конец памяти
out SPL, R20		; 

in R20, TIMSK		; регистр отвечающий за таймер
ori R20, 2			; установили бит 1 в 1 (разрешаем прерывания таймера 0 по переполнению)
out TIMSK, R20		; отправили назад

in R20, GIMSK		; читаем GIMSK, чтобы изменив нужное записать обратно
ori R20, 64			; установили бит 6 (разрешаем прерывания по INT0)
out GIMSK, R20		; отправили назад

; выбираем тип активного сигнала на линии INT0 – низкий уровень
in R20, MCUCR		; читаем MCUCR
andi R20, 255-3		; сбросили два мл. бита
out MCUCR, R20		; отправили назад

; Устанавливаем делитель таймера 0, запуская счет
ldi R20, 5			; установили биты CS02, CS01, CS00 – коэф. деления 1024
out TCCR0, R20

; инициализируем таймер 0, разрешаем прерывания
bset 7				; SREG.7=1 – разрешить IRQ (аналог sei)

loop:
rjmp loop		; переход если SREG.Z=0 (R17>0)

; обработчики прерываний
cause:
	inc R16; зарегистрировали событие
reti
	
full:
	dec R17
	brbc 1, result
reti

result:
	……
	; например, вывод на индикатор (экран)
	……
	; реинициализация глобальных переменных
	ldi R17,16
	ldi R16,0
	rjmp main
ret