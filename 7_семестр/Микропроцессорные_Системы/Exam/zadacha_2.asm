0) Так как потребуется обработка внешних прерываний, то сперва необходимо
настроить stack

LDI R20, 127
OUT SPL, R20

1) Необходимо сконфигурировать линии порта PD
PD3 (Fs - начало преобразования в АЦП)
и PD4 (RVx - считывание из АЦП полученных цифровых данных) на выход:

LDI R16, 0b00011000 	(PD3 и PD4 - подаются 1, чтобы были выходами)
OUT DDRD, R16 			(отправляем в регистр направления порта D)
OUT PortD, R16			(изначально PD3 и PD4 = 1)

сконфигурировать порт PB на вход (для приема данных с АЦП):

LDI R16, 0b00000000 	(все 0, чтобы были входами)
OUT DDRB, R16 			(отправляем в регистр направления порта B)

2)Необходимо разрешить внешнее прерывание INT0
IN R17, GIMSK
ORI R17, 0b01000000 	(6ой бит - разрешение прерывания INT0)
OUT GIMSK, R17

IN R17, MCUCR
ORI R17, 0b00000010 	(последние 2 бита - настройка активного сигнала INT0)
						(здесь нам хочется по заднему фронту)
OUT MCUCR, R17

3) Для соблюдения заданных временных интервалов (периодичность опроса АЦП
и удержание низкого уровня сигнала WR заданный промежуток времени) необходимо
использовать оба таймера: 8-разрядный для WR, 16-разрядный для периода опроса:

IN R17, TIMSK
ORI R17, 0b01000010 	(6ой бит - разрешение прерывания таймера 1 по сравнению)
						(1ый бит - разрешение прерывания таймера 0 по переполнению)
OUT TIMSK, R17

Таймер 0 8-разрядный => считает 255 тактов (при коэф. деления = 1 имеем 63,75мкс,
что в разы больше требуемого, при коэф. деления 1024 имеем 65,28мс), значит
необходимо внести начальное значение для таймера 0 такое, чтобы отсчет от этого
начального значения до переполнения составлял от 12 мкс до 13 мкс
(12мкс/250нс=48 тактов, т.е. начальное значение 255-47=208)

LDI R17, 208
OUT TCNT0, R17

Таймер 1 настроен на режим прерывания по сравнению => нужно в регистрах TCNT1H:TCNT1L установить
значение с которым хотим сравнивать текущее значение таймера

LDI R17, 0
OUT TCNT1H, R17			(предварительно обнуляем содержание TCNT1H)
OUT TCNT1L, R17			(предварительно обнуляем содержание TCNT1H)
OUT TCCR1A, R17			(?обнуляем TCCR1A, чтобы отключить таймер от вывода OC1?)

LDI R18, 0				(период опроса АЦП 512*V=512*20=10240 ТАКТОВ = 2800h)
LDI R19, 0x28
OUT OCR1AH, R19
OUT OCR1AL, R18

Перед запуском таймера следует разрешить прерывания (флаг 7 регистра SREG)

BSET 7

Запускаем таймер 1

LDI R17, 1				(коэф. деления = 1)
OUT TCCR1B, R17
OUT TCCR0, R17

4) Когда придет прерывание от ТАЙМЕРА 1 (по сравнению), т.е. через 512*V тактов, сбросим вывод PD3 (CS)
и запустим ТАЙМЕР 0 (OUT TCCR0, R17), выходим из прерывания (reti). Когда придет прерывание от
ТАЙМЕРА 0, уставим вывод PD3, остановим работу ТАЙМЕРА 0



timer_1_int:
	CBI PortD, 3		(опустили CS)
	LDI R17, 1			(коэф. деления = 1)
	OUT TCCR0, R17		(запустили таймер 0)
reti



timer_0_int:
	LDI R17, 0			(остановка таймера 0)
	OUT TCCR0, R17		(остановка таймер 0)

	SBI PortD, 3
	
	И установим начальное значение для следующего запуска таймера 0 по приходу прерывания таймера 1
	LDI R17, 208
	OUT TCNT0, R17
reti



INT0_function:
	CBI PortD, 4
	IN R18, PinB
	SBI PortD, 4
reti



filter_function: (будем считать, что на этапе инициализации X настроен на начало массива (60h)
и по адресу 60h лежат коэффициенты для заданного фильтра (допустим 10 штук)). Результат суммы
будем хранить в R21:R20

	CPI R26, 0x60+10
	BRBC 1, not_clear_R26
		LDI R26, 0x60
		CLR R20
		CLR R21
		
not_clear_R26:
	LDI R16, 1			(константа для сравнения коэф. фильтра с 1)
	LDI R15, 0			(константа для учета переноса из младшего байта суммы)
	
	LD R19, X+			(берем очередной коэф. из памяти)
	
	CPSE R19, R16		(если этот коэф. = 1 то пропускаем команду)
		MUL R18, R19	(умножение на 2/ результат в регистрах R1:R0)
	
	ADD R20, R0			(складываем текущее значение с АЦП с промежуточной суммой)
	ADC R21, R1			(учитываем перенос при сложении младших частей)
	rjmp result_write
ret


result_write: (выводы порта D PD0, PD1, PD6 сконфигурированы на выход на этапе инициализации)
	LDI R22, 0b11111111		(подаются 1, чтобы были выходами)
	OUT DDRB, R22 			(отправляем в регистр направления порта B)
	
	OUT PortB, R20
	SBI PortD, 0
	CBI PortD, 0
	
	OUT PortB, R21
	SBI PortD, 1
	CBI PortD, 1
	rjmp strob
ret

strob: (таймер 0 уже занят под задачу 2 ч.1 => воспользуемся программным способом стробирования)
	LDI R23, 25 (потому что надо выдержать 100 тактов, а в цикле у нас 4 такта)
	SBI PortD, 6
wait_loop:
	DEC R23				(1 такт)
	CPSE R23, R15		(1 такт - если не пропускаем некст команду)
	rjmp wait_loop		(2 такт)
ret