; ================ А-08-19 Балашов ================

; ================ Объявление констант ================

; Последовательный интерфейс
CS6_on		equ 11111101b
CS7_on		equ 11111011b
CLR_bit		equ p1.3

; Порт 3
GREEN_bit	equ p3.0
INT0_bit	equ p3.2
RED_bit		equ p3.3
Y1_bit		equ p3.4
Y3_bit		equ p3.5
WR_bit		equ p3.6
RD_bit		equ p3.7

; Прерывания для регистров
CS1_on		equ 11111000b											; CS1-2ой бит (младшие два бита для адреса)
CS2_on		equ 11110100b											; CS2-3ий бит
CS3_on		equ 11101100b											; CS3-4ый бит
CS4_on		equ 11011100b											; CS4-5ый бит
CS5_on		equ 10111100b											; CS5-6ой бит

CS_off		equ 11111100b

press_key	equ R7
current_key equ R3

; Упрощения жизни
G			equ 8													; номер группы
M			equ 4													; номер варианта по журналу
Error		equ 10000110b											; буква E (расшифровка бинарного числа: - g f E d c b a)

; ================================================ СЕГМЕНТ ДАННЫХ ================================================
dseg at 30h 

			   	;  цифра 0    цифра 1    цифра 2    цифра 3    цифра 4    цифра 5    цифра 6    цифра 7    цифра 8    цифра 9
numbers_mass:  db 11000000b, 11111001b, 10100100b, 10110000b, 10011001b, 10010010b, 10000010b, 11111000b, 10000000b, 10010000b

buffer_size: ds 2 													; размер буфера 32·(M mod 10 + G)+2 двубайтовых записей

ind1: ds 1															; правая часть индикации
ind2: ds 1															; левая часть индикации

LB_num: ds 1														; младшая часть двубайтового числа
HB_num: ds 1														; старшая часть двубайтового числа

Q: ds 1																; значение Q (по ТЗ начальное значение Q=2*G+M)
X5: ds 2
counter: ds 1 														; количество байт в буффере
start_pointer: ds 2													; двубайтовый указатель на первую занятую ячейку в SRAM
end_pointer: ds 2													; двубайтовый указатель на последнюю занятую ячейку в SRAM

adrUART: ds 2

; ================================================ СЕГМЕНТ КОДА ================================================
cseg

org 03h
jmp int_KB															; прерывание от клавиатуры
org 0Bh
jmp int_Y1															; прерывание от таймера 0
org 1Bh
jmp int_Y3															; прерывание от таймера 1
org 2Bh
jmp int_ADC															; прерывание от таймера 2

org 40h
; =================== Основная программа ===================
start:
	call init
	setb EX0														; разрешение прерывания от клавиатуры
	after_init:
		jmp after_init
end start

; ===================== Инициализация ======================
init:
	clr  EA															; запрет прерываний
	
	clr a															; очистили аккумулятор
	mov a, #G														; положили туда номер группы
	mov b, #2											
	mul ab															; умножили номер группы на 2
	add a, #M														; в аккумуляторе получаем 2*G+M
	mov Q, a														; задали начальное значение для Q=2*G+M
	clr a															; очистили аккумулятор
						
	; call init_buf						
	call init_MC_ports												; инициализация выводов контроллера
	call clear_DPY													; очистка индикации
	call init_KB													; инициализация регистра клавиатуры
	call init_UART													; инициализация UART
	call init_SRAM													; инициализация SRAM
	call init_timer													; инициализация таймеров\прерываний
	setb EA															; разрешение прерываний
ret

; =========== Инициализация буфера ============
; init_buf:
; 	mov buffer_size, #04h
; 	mov buffer_size+1, #03h	
; 	clr c 
; 	mov a, buffer_size
; 	subb a, end_pointer
; 	mov a, buffer_size+1
; 	subb a, end_pointer+1
; ret

; =========== Инициализация выводов контроллера ============
init_MC_ports:
	clr Y3_bit														; p3.5=0 (не активен)
	setb GREEN_bit													; p3.0=0 (не активен)
	setb RED_bit													; p3.3=0 (не активен)
													
	setb Y1_bit														; p3.4=1 (не активен)
	setb CS6_on														; p1.1=1 (не активен)
	setb WR_bit														; p3.6=1 (не активен)
	setb RD_bit														; p3.7=1 (не активен)
	setb CLR_bit													; p1.3=1 (не активен)
													
	mov p0, #0														; p0=0
	mov p2, #CS_off													; внешние устройства не выбраны
ret

; ==================== Очистка индикации ===================
clear_DPY:

	mov a, #11111111												; очищаем левую цифру индикации
	mov dph, #CS3_on
	mov dpl, #0
	movx @dptr, a

	mov a, #11111111												; очищаем правую цифру индикации
	mov dph, #CS4_on
	mov dpl, #0
	movx @dptr, a
												
	mov ind1, #-1													; сбросили индикаторы в начальное состояние
	mov ind2, #-1													; сбросили индикаторы в начальное состояние
												
	mov LB_num, #-1													; сброс младшей части двубайтового числа
	mov HB_num, #-1													; сброс старшей части двубайтового числа
												
	clr GF0															; опускаем флаг ошибки
ret

; ================= Инициализация клавиатуры ===============
init_KB:
	clr WR_bit														; WR=0
	mov p2, #CS2_on	    											; выбираем регистр для стобцов
	mov p0, #00001111b												; активируем все столбцы (нулями)
	mov p2, #CS_off													; отключаем регистр для стобцов
	setb WR_bit														; WR=1
	mov p0, #11111111b												; возвращаем порт в состояние 11111111
												
	clr RD_bit														; RD=0
	mov p2, #CS1_on													; выбираем регистр для строк
	mov p2, #CS_off													; отключаем регистр для строк
	setb RD_bit														; RD=1
	
	mov press_key, #-1												; изначально нажатая клавиша сброшена
	mov current_key, #-1											; изначально текущая нажатая клавиша сброшена
ret

; =================== Инициализация UART ===================
init_UART:
	mov adrUART, #0													; базовый адрес UART 0
	mov adrUART+1, #0	

	; регистр SCON
	mov SCON, #10000000b											; (первые два бита SM0 и SM1) 9-bit UART mode
ret

; =================== Инициализация SRAM ===================
init_SRAM:
	mov buffer_size, #04h											; младшая часть числа 772
	mov buffer_size+1, #03h											; старшая часть числа 772

	mov dph, #CS5_on												; в старшую часть dptr кладем 10111100b(младшие два бита для адреса)
	mov dpl, #0														; в младшую часть dptr кладем 0
											
	mov start_pointer, #0											; при инициализации первый байт start_pointer = 0
	mov a, start_pointer										
	movx @dptr, a													; в самом начале SRAM будет лежать указатель на начало кольцевого буфера
											
	inc dptr														; указатели двубайтовые, значит переходим ко 2му байту
	mov start_pointer+1, #4											; при инициализации второй байт start_pointer = 4
	mov a, start_pointer+1										
	movx @dptr, a													; второй байт указателя на начало кольцевого буфера
											
	inc dptr														; переходим к следующей ячейке
	mov end_pointer, #0												; при инициализации первый байт end_pointer = 0
	mov a, end_pointer										
	movx @dptr, a													; после указателя на начало будет лежать указатель на конец кольцевого буфера
											
	inc dptr														; указатели двубайтовые, значит переходим ко 2му байту
	mov end_pointer+1, #4											; при инициализации второй байт end_pointer = 4
	mov a, end_pointer+1										
	movx @dptr, a													; второй байт указателя на конец кольцевого буфера
ret

; ================ Инициализация таймеров ================
init_timer:
	; TIMER0	работа с Y1
	; TIMER1	работа с Y3
	; TIMER2	работа с АЦП
		
	; регистр TCON (регистр режима таймера 2):
	setb IT0 														; по спаду сигнала на входе для прерывания от таймера 0 (регистр TCON)
	setb IT1 														; по спаду сигнала на входе для прерывания от таймера 1 (регистр TCON)
	clr TF0															; таймер 0 - режим перезагрузки при переполнении
	clr TF1															; таймер 1 - режим перезагрузки при переполнении
	clr TF2															; таймер 2 - режим перезагрузки при переполнении
	
	; регистр EI (регистр разрешиния прерывания):
	setb EX0 														; разрешение прерываний от INT0 для клавиатуры
	setb ET0 														; разрешение прерываний от таймера 0
	setb ET1 														; разрешение прерываний от таймера 1
	setb ES 														; разрешения прерываний от UART
	
	; регистр IP (регистр приоритета прерываний):
	setb PT2 														; с максимальным приоритетом для таймера 2

	; регистр SPCR:
	setb MSTR 														; SPI в режиме Master
	clr SPR0 														; если SPR0=SPR1=0, то частота будет делиться на 4 (по даташиту)
	clr SPR1 														; 12/4=3 МГц (АЦП на такой частоте работать может)

	; регистр TMOD:
	mov TMOD, #00010001b											; счетчики Т0 и Т1 в 16-битном режиме, GATE=0 (запуск по TR0=1), t/C = 0 (режим таймера)

	
	; регистр T2CON (регистр режима таймера 2):
	clr T2CON.0 													; таймер 2 - режим перезагрузки при переполнении
	clr T2CON.1         											; режим таймера по внутренниему генератору
	MOV RCAP2H,#0FCh 												; каждые 800 мкс
	MOV RCAP2L,#0DFh    											; таймер переполняется, когда TH2 и TL2 и равны значениям, хранящимся в RCAP2H и RCAP2L
											
	clr TR0															; таймер 0 выкл
	clr TR1 														; таймер 1 выкл
	setb TR2 														; таймер 2 вкл
ret

; ================ Прерывание от таймера 2 (работа с АЦП) ================	
int_ADC:
	clr TF2															; сбросить переполнение счетчика 2
	mov r0, X5											
												
	mov p1, CS7_on													; запускаем конвертацию
	nop 															; ждём пока обработает (необязательно)
	mov p1, CS_off													; отключаем разрешение, чтобы АЦП не ушёл в сберегающий режим
											
	mov p1, CS6_on													; разрешаем работу вывода АЦП
	setb SPE														; разрешаем SPI
	mov SDTR, #0 													; 
	jnb SPIF, $														; ждем окончания приема
	mov @r0, SPDR													; как закончили - старшую часть в r2
	inc r0											
	clr SPIF											
	jnb SPIF, $											
	mov @r0, SPDR													; младшую часть в r3
	clr SPIF											
	mov p1, #CS_off													; запрещаем работу вывода АЦП
	clr SPE															; запрещаем SPI
												
	clr a															; очистили аккумулятор
	clr c															; очистили carry
	mov a, Q														; положили туда Q
	mov b, #3											
	mul ab															; умножили Q на 3
												
	mov r4, a														; младшую часть 3*Q кладем в r4
	mov r5, b														; старшую часть 3*Q кладем в r5
												
	add a, #G														; прибавляем к младшей части G
	mov r4, a														; кладем младшую часть 3*Q+G в r4
	mov a, r5														; смотрим на старшую часть 3*Q+G
	addc a, #0														; и если в младшей части было переполнение, то
	mov r5, a														; в r5 поместится корректное значение старшей части от 3*Q+G
											
	clr c															; очистили carry
	mov a, r4														; достаем младшую часть 3*Q+G
	subb a, #2*M													; вычитаем 2*M
	mov r4, a														; и кладем младшую часть 3*Q+G-2*M в r4
	mov a, r5														; смотрим на старшую часть 3*Q+G-2*M
	subb a, #0														; и если в младшей части был заём, то
	mov r5, a														; в r5 поместится корректное значение старшей части от 3*Q+G-2*M
												
	clr c															; очистили carry
	mov a, r5														; для проверки на отрицательное число 3*Q+G-2*M
	rlc a															; сдвигаем старшую часть 3*Q+G-2*M влево на 1 разряд
	jc negative_number												; и если carry поднялся, значит число отрицательное
	jmp positive_number
	
negative_number:
	mov a, r4														; смотрим младшую часть 3*Q+G-2*M
	cpl a															; инвертируем
	inc a															; прибавляем 1
	mov r4, a														; и кладем обратно
												
	mov a, r5														; смотрим старшую часть 3*Q+G-2*M
	cpl a															; инвертируем
	mov r5, a														; и кладем обратно (так мы получили модуль отрицательного числа)
												
positive_number:											
	clr c															; очистили carry
												
	dec r0															; мы хотим сравнить X5 с 3*Q+G-2*M
	mov a, @r0														; для это вычтем из X5 число 3*Q+G-2*M
	subb a, r4														; вычитаем из младшей части X5 младшую часть 3*Q+G-2*M
												
	inc r0															; загружаем старшую часть
	mov a, @r0														; в аккумулятор
	subb a, r5														; вычитаем из старшей части X5 старшую часть 3*Q+G-2*M
	
	jc RED_indication_off											; если X5>|3Q+G–2M|, то carry поднят
	clr RED_bit														; то включаем красный светодиод
	jmp WR_number_in_SRAM											; и переходим к записи числа в SRAM
	
RED_indication_off:
	setb RED_bit													; иначе отключаем красный светодиод
												
WR_number_in_SRAM:											
	dec r0															
	mov a, @r0														; берем младшую часть X5
	add a, #M														; и прибавляем M (по ТЗ это Y2)
	mov r4, a														; сохраняем младшую часть Y2 в регистр r4
												
	inc r0											
	mov a, @r0														; берем старшую часть X5
	addc a, #0														; если в младшей части было переполнение, то тут это учтется
	mov r5, a														; сохраняем старшую часть Y2 в регистр r5
	
	mov a, end_pointer												; кладем в acc старшую часть указателя на последнюю запись в SRAM
	orl a, #CS5_on													; поднимаем ненужные биты CS
	anl a, #10111111b												; опускаем бит CS5 (разрешение работы с SRAM)
	mov dph, a														; результат кладем в старшую часть dptr
	mov dpl, end_pointer+1											; а в младшую часть dptr просто кладем младшую часть этого указателя
										
	mov a, r4														; кладем в acc младшую часть Y2
	movx @dptr, a													; и отправляем в SRAM
	inc dptr														; инкрементируем dptr
	mov a, r5														; кладем в acc старшую часть Y2
	movx @dptr, a													; и отправляем в SRAM
	inc dptr														; тут dptr указывает на следующую пустую ячейку
										
	mov end_pointer, dph											; end_pointer = dptr
	mov end_pointer+1, dpl											; end_pointer = dptr
										
	mov a, counter													; кладем в acc counter и смотрим чему он равен
	cjne a, #32, inc_counter										; если counter <32, то нужно его увеличить
	jmp not_inc_counter												; если counter 32, то дальше он не увеличивается
										
inc_counter:									
	inc counter														; когда counter 32 мы можем позволить себе вывод через UART
										
not_inc_counter:									
	clr c															; чистим флаг carry
	mov a, buffer_size												; нужно сравнить размер буффера с указателем
	subb a, end_pointer												; размер буффера - двубайтовая переменная
	mov a, buffer_size+1											; указатель - тоже двубайтовый
	subb a, end_pointer+1											; вычитаем старшие части
										
	jnc is_not_end_of_buffer										; если возникло переполнение, значит указатель > размера буффера
	
	mov end_pointer, start_pointer									; и тогда нужно переопределить указатель
	mov end_pointer+1, start_pointer+1								; на начало буффера

is_not_end_of_buffer:	
	mov dptr, #2													; нужно перезаписать в SRAM end_pointer
	mov dph, #CS5_on												; старшая часть dptr разрешает работу со SRAM (CS5)
	mov a, end_pointer												; кладем в acc старшую часть указателя
	movx @dptr, a													; и отправляем в SRAM
										
	inc dptr														; 
	mov a, end_pointer+1											; кладем в acc младшую часть указателя
	movx @dptr, a													; и отправляем в SRAM
	

reti

; ============= Прерывание INT0 от клавиатуры ==============
int_KB:
	clr EX0															; запрет прерывания от клавиатуры
											
	mov r6, #11101111b												; старшая тетрада - столбцы (выбираем первый)
	mov r2, #0														; значение, нужное для перевода в нормальный вид
											
	search_column:										
		clr WR_bit													; WR=0
		mov p1, r6													; отправляем на шину 0 в один из столбцов
		mov p2, #CS2_on	    										; кладем в регистр для стобцов один из столбцов
		mov p2, #CS_off												; отключаем регистр для стобцов
		setb WR_bit													; WR=1
												
		clr RD_bit													; RD=0
		mov p2, #CS1_on												; считываем в регистр строк строки и выводим на шину
		mov a, p1													; кладем в аккумулятор считанные строки
		mov p2, #CS_off												; отключаем регистр для строк
		setb RD_bit													; RD=1
												
		orl a, #11110000b											; младшая часть - считанная комбинация строк
		cpl a 														; инвертируем содержимое аккумулятора
		jnz search_button											; если в итоге все нули, значит кнопка не в этом столбце
												
		mov a, r6 													; кладем в аккумулятор текущий столбец
		rl a														; переходим на следующий столбец
		mov r6, a
		mov a, r2	
		add a, #1
		mov r2, a
		cjne r6, #11111110b, search_column							; пока не пробежались по всем столбцам, продолжаем
	jmp exit_int_KB

	search_button:
		cjne a, #1, numtwo											; если нажата не первая, переходим ко второй
		mov a, #1													; номер первой к в строке
		add a, r2													; +"смещение" дают нам нужную клавишу
		jmp result_press_key									
											
	numtwo:									
		cjne a, #2, numthree										; если нажата не вторая, переходим к третьей
		mov a, #5													; второй символ в строке
		add a, r2													; "смещение" в строке
		jmp result_press_key									
											
	numthree:									
		cjne a, #4, numfour											; если нажата не третья, значит нажата четвертая
		mov a, #9													; третий символ в столбце
		add a, r2													; "смещение" в строке
		jmp result_press_key									
											
	numfour:									
		mov a, #13													; четвёртый символ в столбце
		add a, r2													; "смещение" в строке
		jmp result_press_key									
									
	result_press_key:									
		mov press_key, a											; кладем в press_key код нажатой клавиши
									
	exit_int_KB:									
		call Proc_KB_check									
		call init_KB												; возвращаем клавиатуру в состояние по умолчанию
reti									

; ================ Проверка нажатой клавиши ================
Proc_KB_check:
	mov a, press_key												; кладем нажатую клавишу в аккумулятор
	add a, #1														; если нажатая клавиша сброшена, значит её не удалось поймать
	jz err3															; и тут 0, значит была ошибка
	
	mov dptr, #numbers_mass
	
clr_button:
	cjne press_key, #15, input_button								; нажата клавиша сброса? (если не она, переходим на след. метку)
	call clear_DPY													; если это она, вызываем функцию очистки индикации
	jmp end_proc_KB_check											; и вернемся на начало цикла
								
input_button:							
	jb GF0, end_proc_KB_check										; поднят флаг ошибки, ждем только кнопку сброса
	cjne press_key, #13, A_button									; нажата клавиша ввода? (если не она, переходим на след. метку)
	call proc_input_button											; если это она, вызываем функцию клавиши ввода
	jmp end_proc_KB_check											; и вернемся на начало цикла
								
A_button:							
	cjne press_key, #4, B_button									; нажата клавиша A? (если не она, переходим на след. метку)
	call proc_A_button												; если это она, вызываем функцию клавиши A
	jmp end_proc_KB_check											; и вернемся на начало цикла
								
B_button:							
	cjne press_key, #8, C_button									; нажата клавиша B? (если не она, переходим на след. метку)
	call proc_B_button												; если это она, вызываем функцию клавиши B
	jmp end_proc_KB_check											; и вернемся на начало цикла
								
C_button:							
	cjne press_key, #12, D_button									; нажата клавиша C? (если не она, переходим на след. метку)
	call proc_C_button												; если это она, вызываем функцию клавиши C
	jmp end_proc_KB_check											; и вернемся на начало цикла
								
D_button:							
	cjne press_key, #16, Number_button								; нажата клавиша D? (если не она, переходим на след. метку)
	call proc_D_button												; вызываем функцию клавиши D
	jmp end_proc_KB_check											; и вернемся на начало цикла
							
Number_button:							
	button_zero:
		cjne press_key, #14, button_one								; индекс клавиши =0? (если нет, то к следующей метке)
		mov current_key, #0											; запоминаем текущую нажатую клавишу (0)
		jmp next						
	button_one:						
		cjne press_key, #1, button_two								; индекс клавиши =1? (если нет, то к следующей метке)
		mov current_key, #1											; запоминаем текущую нажатую клавишу (1)
		jmp next						
	button_two:						
		cjne press_key, #2, button_three							; индекс клавиши =2? (если нет, то к следующей метке)
		mov current_key, #2											; запоминаем текущую нажатую клавишу (2)
		jmp next						
	button_three:						
		cjne press_key, #3, button_four								; индекс клавиши =2? (если нет, то к следующей метке)
		mov current_key, #3											; запоминаем текущую нажатую клавишу (3)
		jmp next						
	button_four:						
		cjne press_key, #5, button_five								; индекс клавиши =3? (если нет, то к следующей метке)
		mov current_key, #4											; запоминаем текущую нажатую клавишу (4)
		jmp next						
	button_five:						
		cjne press_key, #6, button_six								; индекс клавиши =4? (если нет, то к следующей метке)
		mov current_key, #5											; запоминаем текущую нажатую клавишу (5)
		jmp next						
	button_six:						
		cjne press_key, #7, button_seven							; индекс клавиши =5? (если нет, то к следующей метке)
		mov current_key, #6											; запоминаем текущую нажатую клавишу (6)
		jmp next						
	button_seven:						
		cjne press_key, #9, button_eight							; индекс клавиши =6? (если нет, то к следующей метке)
		mov current_key, #7											; запоминаем текущую нажатую клавишу (7)
		jmp next						
	button_eight:						
		cjne press_key, #10, button_nine							; индекс клавиши =7? (если нет, значит 9)
		mov current_key, #8											; запоминаем текущую нажатую клавишу (8)
		jmp next						
	button_nine:						
		mov current_key, #9											; запоминаем текущую нажатую клавишу (9)
						
next:								
	mov a, current_key
	movc a, @a+dptr
	mov r0, a
	
	mov a, ind1														; кладем правую часть индикации в аккумулятор
	cjne a, #-1, left_shift											; если на правой индикации уже горит цифра, то нужно сделать сдвиг индикации влево
	mov ind1, @r0													; иначе кладем нажатую клавишу в правую часть индикации
	mov LB_num, #current_key										; кладем текущее значение нажатой клавиши в LB_num
										
left_shift:									
	mov r2, ind1													; правую часть индикации сохраняем в R2
	mov HB_num, LB_num												; кладем предыдущее значение нажатой клавиши в HB_num
	mov LB_num, #current_key										; кладем текущее значение нажатой клавиши в LB_num
	mov ind2, r2													; и кладем в левую часть индикации
										
	mov ind1, @r0													; в правую часть индикации вносим новую нажатую клавишу
									
	call enter_DPY													; нажата клавиша-цифра, вызываем соответствующую функцию
	jmp end_proc_KB_check									
										
err3:	
	mov ind1, #3													; номер ошибки								
	call Error_Indication											; ошибка: пришло прерывание, а кнопка не найдена
end_proc_KB_check:
ret

; =================== Вывод на индикатор ===================
enter_DPY:

	mov a, ind2														; выводим левую (старшую) цифру индикации
	mov dph, #CS3_on
	mov dpl, #0
	movx @dptr, a

	mov a, ind1														; выводим правую (младшую) цифру индикации
	mov dph, #CS4_on
	mov dpl, #0
	movx @dptr, a

ret

; ============ Обработка нажатия кнопки "Ввод" =============
proc_input_button:	
	mov a, ind1														; кладем в аккумулятор правую часть индикации
	cjne a, #-1, err1												; если индикатор 1 пустой, то ошибка (пытаемся сохранить невведенное число)
											
	mov a, HB_num										
	mov b, #10														; получаем число десятков
	mul ab										
	add a, LB_num
	mov Q, a
	
	; 1/(11,0594*10^6/12)*X=M мс => X=M*11,0594*10^6/12
	; для M=4 мс, X=3686 тиков (чтобы выдержать 4 мс)
	; 65536-3686=61849=0F199h
	
	mov TH0, #0D8h 													; занесение старшую части счетчика 0
	mov TL0, #66h													; занесение младшей части счетчика 0
	clr Y1_bit														; выдаем строб Y1 (активный уровень = 0)
	setb TR0														; сигнал разрешения работы счетчика 0 (регистр TCON)
											
	call clear_DPY													; выключаем индикатор
										
	call init_KB													; проинициализировать клавиатуру
	jmp end_proc_input_button
	
err1:
	mov ind1, #1													; номер ошибки
	call Error_Indication											; ошибка: пытаемся занести еще невведенное чисто
	
end_proc_input_button:
ret

; ================ Обработка прерывания таймера 0 (строб Y1) ================
int_Y1:
	setb Y1_bit														; возвращаем неактивный уровень уровень строба Y1
	clr TR0															; запрет работы счетчика 0
	clr TF0															; сбросить переполнение счетчика 0
reti

; ============== Обработка нажатия кнопки "A" ==============
proc_A_button:
    clr TR2                     ; запрещаем прерывание от АЦП на момент работы

    clr c                       ; чистим флаг carry
    mov a, counter              ; кладем в аккумулятор текущее кол-во записей в буфере
    subb a, #32                 ; проверяем, есть ли там хотя бы 32 записи
    jc err2                     ; если нет, значит ошибка err2
    
    clr c                       ; чистим флаг carry
    mov a, end_pointer+1        ; кладем в acc младшую часть указателя
    subb a, #1                  ; указатель указывает на первую ПУСТУЮ ячейку
    mov adrUART+1, a            ; а мы хотим последнюю ЗАНЯТУЮ ячейку
    
    mov a, end_pointer          ; кладем в acc старшую часть указателя
    subb a, #0                  ; учитываем перенос из младшей
    orl a, #CS5_on              ; поднимаем ненужные биты CS
    anl a, #10111111b           ; опускаем бит CS5 (разрешение работы с SRAM)
    mov adrUART, a              ; 

    clr c                       ; очищаем флаг carry
    mov a, adrUART+1            ; инфернальная проверка на повторую запись
    subb a, #3                  ; смысл такой:
    jnz skip                    ; когда наш буффер был полностью забит, мы начали
    mov a, adrUART              ; записывать данные "по второму кругу" - поверх старых
    subb a, #CS5_on             ; а значит нужно вывести N "повторных" записей
    jnz skip                    ; а дальше выводить записи, начиная с конца буффера
    
    mov a, #CS5_on
    orl a, #00000011b
    mov dph, a                  ; настраиваем dptr
    mov dpl, #00000100b         ; на конец буффера
	jmp cycle
	
skip:
    mov dph, adrUART            ; настраиваем dptr
    mov dpl, adrUART+1          ; на последнюю ЗАНЯТУЮ ячейку
    
cycle:
    movx a, @dptr               ; тут dptr указывает на старший байт двубайтовой запсии
    mov SBUF, a                 ; начало передачи по UART старшего байта
    jnb TI, $                   ; ждем окончания передачи данных
    
    clr TI                      ; сбрасываем бит окончания передачи данных
    
    clr c                       ; очищаем флаг carry
    mov a, dpl                  ; команды dec dptr нет :( поэтому загружаем в аккумулятор младшую часть dptr
    subb a, #1                  ; вычитаем из младшей части dptr 1
    mov dpl, a                  ; кладем назад декрементированный dptr
    mov a, dph                  ; загружаем в аккумулятор старшую часть dptr
    subb a, #0                  ; вычитаем из старшей части dptr 1, если был заем в сладшей части
    mov dph, a                  ; кладем назад декрементированный dptr
    
    movx a, @dptr               ; тут dptr указывает на младший байт двубайтовой запсии
    mov SBUF, a                 ; начало передачи по UART младшего байта
    jnb TI, $                   ; ждем окончания передачи данных
    
    clr TI                      ; сбрасываем бит окончания передачи данных
    
    mov a, counter
    mov b, #10
    div ab
    mov ind1, b                 ; правая часть индикации (остаток от деления counter на 10)
    mov ind2, a                 ; левая часть индикации (результат деления counter на 10)
    
    call enter_DPY
    
    clr c                       ; очищаем флаг carry
    mov a, dpl                  ; команды dec dptr нет :( поэтому загружаем в аккумулятор младшую часть dptr
    subb a, #1                  ; вычитаем из младшей части dptr 1
    mov dpl, a                  ; кладем назад декрементированный dptr
    mov a, dph                  ; загружаем в аккумулятор старшую часть dptr
    subb a, #0                  ; вычитаем из старшей части dptr 1, если был заем в сладшей части
    mov dph, a                  ; кладем назад декрементированный dptr
    
    mov adrUART, dph            ; кладем в переменную adrUART текущий dptr
    mov adrUART+1, dpl          ; для просмотра: где сейчас этот указатель
           
    djnz counter, cycle         ; если вывели ещё не все записи, приступаем к выводу следующей
    
    mov counter, #32            ; возвращаем значение счетчика
    
    jmp end_proc_A_button

err2:
    mov ind1, #2
    call Error_Indication       ; ошибка: в буффере недостаточно записей для вывода
    
end_proc_A_button:
    call clear_DPY              ; выключаем индикатор
    setb TR2                    ; снова разрешаем работу АЦП
ret

; ============= Обработка нажатия кнопки "B" ===============
proc_B_button:
	; 1/(11,0594*10^6/12)*X=G мс => X=G*11,0594*10^6/12
	; для G=8 мс, X=7373 тиков (чтобы выдержать 8 мс)
	; 65536-7373=58163=0E333h
	
	mov TH1, #0E3h 													; занесение старшую части счетчика 1
	mov TL1, #33h													; занесение младшей части счетчика 1
	setb Y3_bit														; запускаем генератор импульсов Y3
	setb GF1														; наш флаг для отслеживания текущего значения Y3 (ставим 1)
	setb TR1														; сигнал разрешения работы счетчика 1
	clr GREEN_bit													; зажигаем зеленый светодиод
ret

; ========== Обработка int таймера 1 (импульсы Y3) =========
int_Y3:
	jb GF1, set_low_Y3
	
	clr TF1															; сбросить переполнение счетчика 1
	clr TR1															; запрет работы счетчика 1
	mov TH1, #0E3h 													; занесение старшую части счетчика 1
	mov TL1, #33h													; занесение младшей части счетчика 1
	setb Y3_bit														; переключаемся на высокий уровень Y3
	setb TR1														; сигнал разрешения работы счетчика 1
	setb GF1														; наш флаг для отслеживания текущего значения Y3 (ставим 1)
	jmp end_int_Y3										
											
set_low_Y3:										
	clr TF1															; сбросить переполнение счетчика 1
	clr TR1															; запрет работы счетчика 1
	
	; 1/(11,0594*10^6/12)*X=(T-t) мс => X=(T-t)*11,0594*10^6/12
	; для M=4 (T-t)=22 мс, X=20275 тиков (чтобы выдержать 22 мс)
	; 65536-20275=45261=0B0CDh
	
	mov TH1, #B0h 													; занесение старшую части счетчика 1
	mov TL1, #CDh													; занесение младшей части счетчика 1
	clr Y3_bit														; переключаемся на низкий уровень Y3
	setb TR1														; сигнал разрешения работы счетчика 1
	clr GF1															; наш флаг для отслеживания текущего значения Y3 (ставим 0)
	
end_int_Y3:
reti

; ================ Обработка нажатия кнопки "C" ================
proc_C_button:
	clr TF1															; сбросить переполнение счетчика 1
	clr TR1															; запрет работы счетчика 1	
	clr Y3_bit														; останавливаем генератор импульсов Y3
	clr GF1															; наш флаг для отслеживания текущего значения Y3 (ставим 0)
	setb GREEN_bit													; отключаем зеленый светодиод
ret

; ================ Обработка нажатия кнопки "D" ================
proc_D_button:														; Запасная кнопка
	nop
	nop
	nop
	nop
ret

; ===================== Таблица ошибок =====================
		;Err1 Нажали ввод, на введя чило
		;Err2 Хотим UART, а у нас меньше 32 готовых записей
		;Err3 Пришло прервание от KB, но клавиша не найдена
; ==========================================================

; ============== Вывод ошибки на индикатор ==============
Error_Indication:
	setb GF0				; поднимаем флаг ошибки
	mov ind2, #E			; буква E
	call enter_DPY			; выводим на индикатор
ret