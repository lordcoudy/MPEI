
<html>
<head>



<meta name="Description" content="Н. А. Олифер, В. Г. Олифер, Центр Информационных Технологий. Введение в Mach
">


<title>Введение в Mach
</title>
</HEAD><BODY bgcolor="#FFF5EE" text="#000000" link="#FF0000" alink="#FF0000" vlink="#A52A2A">

<h3><a name="_6_1">Введение в Mach</a></h3>
<h4><a name="_6_1_1">История Mach</a></h4>
<p>
Система Mach имела в качестве предшественницы систему RIG - Rochester Intelligent Gateway, начало разработки которой пришлось на 1975 год. RIG была написана для 16-битового мини-компьютера компании DataGeneral под названием Elipce. Целью этой разработки была демонстрация возможностей структурирования операционной системы и представления ее в виде набора процессов, которые могут взаимодействовать между собой путем передачи сообщений, в том числе и по сети. Затем эта операционная система была улучшена путем добавления средств защиты и средств прозрачной работы в сети и получила название Accent (в 1981 году, в университете Карнеги-Меллона). В 1984 году она уже использовалась на 150 компьютерах PERQ - ранних графических станциях, но проиграла соревнование с UNIX'ом. Это обстоятельство побудило создать третье поколение ОС, использующей механизм обмена сообщениями. Этот проект и был назван Mach. В связи с тем, что Mach проектировалась как система, совместимая с UNIX, планировалась поддержка большого количества приложений для UNIX. Кроме совместимости с UNIX, в Mach были введены и другие усовершенствования, включая нити, улучшенные механизмы межпроцессного взаимодействия, поддержка многопроцессорных систем, улучшенная виртуальная память и др. В это время агентство DARPA искало операционную систему для поддержки мультипроцессоров. Выбор был сделан в пользу университета Карнеги-Меллона, и работы над ОС Mach были продолжены. Было решено сделать эту систему совместимой с 4.2BSD путем комбинации Mach и 4.2BSD в виде единого ядра. Хотя этот подход привел к большому ядру, он гарантировал абсолютную совместимость. Первая версия Mach была реализована в 1986 году для VAX11/784, 4-х процессорной машины. Вскоре эта ОС была перенесена на IBM PC RT и Sun 3. К 1987 году Mach выполнялась также на мультипроцессорах Encore и Sequent. Хотя Mach и имела сетевые средства, ее скорее можно было отнести к ОС отдельной машины или мультипроцессора, а не к сетевой распределенной прозрачной системе. Вскоре была создана организация производителей компьютеров OSF (IBM, DEC, Hewlett Packard) для того, чтобы отобрать контроль над ОС UNIX у ее собственника AT&amp;T. Они выбрали Mach 2.5 в качестве основы для их первой операционной системы OSF/1. Хотя Mach 2 и OSF/1 содержали большое количество кода Berkeley и AT&amp;T, была надежда, что OSF, по крайней мере, сможет контролировать направление развития UNIX. В 1988 году ядро Mach 2.5 было большим и монолитным из-за того, что содержало большое количество кода Berkeley UNIX. А в 1989 году университет Карнеги-Меллона удалил весь код BSD UNIX из ядра и поместил его в пользовательское пространство. То, что осталось, было микроядром, состоящим из чистого кода Mach. Эта версия 3.0 и используется как основа последующих версий OSF.
<h4><a name="_6_1_2">Цели Mach</a></h4>
<p>
ОС Mach значительно изменилась со времени ее первой реализации в виде RIG. Цели проекта также изменились со временем. На текущий момент основные цели выглядят так:
<OL TYPE = 1>
<LI>Обеспечение базовых функций для создания других операционных систем (например, UNIX).
<LI>Поддержка больших разреженных адресных пространств.
<LI>Обеспечение прозрачного доступа к сетевым ресурсам.
<LI>Поддержка параллелизма как в системе, так и в приложениях.
<LI>Обеспечение переносимости Mach на различные типы компьютеров.
</OL>
<h4><a name="_6_1_3">Основные концепции Mach</a></h4>
<p>
Микроядро Mach было разработано в качестве основы, на базе которой можно эмулировать UNIX и другие ОС. Эта эмуляция осуществляется программным уровнем, который работает вне ядра, в пользовательском пространстве (рис. 6.1). Следует отметить, что несколько эмуляторов могут работать одновременно, так что можно выполнять программы 4.3BSD, System V и MS-DOS на одной машине в одно и то же время.
<p>
Ядро Mach, подобно другим микроядрам, обеспечивает управление процессами, управление памятью, коммуникации и функции ввода-вывода. Функции управления файлами, каталогами и другие традиционные для операционных систем функции выполняются в пользовательском пространстве. Идея построения ядра Mach состоит в обеспечении механизмов, необходимых для работы системы, но стратегия использования этих механизмов реализуется на уровне пользовательских процессов.
<p>
Ядро управляет пятью главными абстракциями:
<OL TYPE = 1>
<LI>Процессы
<LI>Нити
<LI>Объекты памяти
<LI>Порты
<LI>Сообщения
</OL>
<p>
<center><img src = "img00088.gif" tppabs="http://ndesign.com.ua/~mik/doc/sos/pictures/img00088.gif" border=1></center>

<p align=center>
<i>Рис. 6.1. Абстрактная модель эмуляции UNIX на основе Mach</i>
<p>
Кроме этого, ядро работает и с некоторыми другими абстракциями, или связанными с указанными, или менее важными.
<p>
<i>Процесс</i> - это, в основном, среда, в которой происходит выполнение. Он имеет адресное пространство, содержащее текст программы и данные, и обычно один или более стеков. Процесс - это базисная единица для распределения ресурсов. Например, коммуникационный канал всегда принадлежит одному процессу.
<p>
<i>Нить</i> в Mach является единицей выполнения. Она имеет счетчик команд и набор регистров, связанных с ней. Каждая нить является частью точно одного процесса. Процесс, состоящий из одной нити, подобен традиционному (например, как в UNIX) процессу.
<p>
Концепцией, уникальной для Mach, является введение понятия <i>объект памяти</i> (memory object), представляющий собой структуру данных, которая может быть отображена в адресное пространство процесса. Объекты памяти занимают одну или несколько страниц и образуют основу для системы управления виртуальной памятью Mach. Когда процесс ссылается на объект памяти, который не представлен в физической памяти, это вызывает страничное прерывание. Как и в других ОС, ядро перехватывает страничное прерывание. Однако в отличие от других систем, ядро Mach для загрузки отсутствующей страницы посылает сообщение серверу пользовательского режима, а не самостоятельно выполняет эту операцию.
<p>
Межпроцессное взаимодействие в Mach основано на передаче сообщений. Для того, чтобы получить сообщение, пользовательский процесс просит ядро создать защищенный почтовый ящик, который называется <i>порт</i>. Порт хранится внутри ядра и способен поддерживать очередь упорядоченного списка сообщений. Очереди не имеют фиксированной длины, но в целях управления потоком для каждого порта отдельно устанавливается пороговое значение в <i>n сообщений</i>, так что всякий процесс, пытающийся послать еще одно сообщение в очередь длины <i>n</i>, приостанавливается для того, чтобы дать порту возможность очиститься.
<p>
Процесс может предоставить другому процессу возможность посылать (или получать) сообщения в один из принадлежащих ему портов. Такая возможность реализуется в виде <i>мандата </i><b>(</b>capability), который включает не только указатель на порт, но и список прав, которыми другой процесс обладает по отношению к данному порту (например, право выполнить операцию ПОСЛАТЬ - SEND). Все коммуникации в Mach используют этот механизм.
<h4><a name="_6_1_4">Сервер Mach BSD UNIX</a></h4>
<p>
Как уже было сказано выше, разработчики системы Mach модифицировали Berkeley UNIX для работы в пользовательском пространстве в форме прикладной программы. Такая структура имеет несколько преимуществ по сравнению с монолитным ядром. Во-первых, система упрощается за счет разделения на часть, которая выполняет управление ресурсами (ядро), и часть, которая обрабатывает системные вызовы (UNIX-сервер), и ею становится легче управлять. Такое разделение напоминает разделение труда в операционной системе VM/370 мейнфреймов IBM, где ядро эмулирует набор &quot;голых&quot; 370-х машин, на каждой из которых реализована однопользовательская операционная система.
<p>
Во-вторых, за счет помещения UNIX'а в пользовательское пространство его можно сделать в высокой степени машинно-независимым. Все машинно-зависимые части могут быть удалены из UNIX'а и скрыты внутри ядра Mach.
<p>
В-третьих, как уже было упомянуто выше, несколько ОС могут работать одновременно. Например, на процессоре Intel 386 Mach может выполнять программу UNIX и программу MS-DOS одновременно. Аналогично возможно одновременное тестирование новой экспериментальной ОС и работа с основной ОС.
<p>
В-четвертых, в систему могут быть введены операции реального времени, потому что все традиционные препятствия для работы в реальном времени, такие как, например, запрет прерываний на время обновления критических таблиц, могут быть либо исключены, либо перенесены в пользовательское пространство. Ядро может быть тщательно структурировано, для того чтобы не препятствовать работе приложений реального времени. Наконец, такое построение системы может быть использовано для обеспечения лучшей защиты между процессами, если она нужна. Если каждый процесс работает со своей версией UNIX'а, то для одного процесса очень трудно что-либо разузнать о файлах другого процесса.

<p><center><a href="glava_23.htm" tppabs="http://ndesign.com.ua/~mik/doc/sos/glava_23.htm">Предыдущая глава</a> || <a href="contents.htm" tppabs="http://ndesign.com.ua/~mik/doc/sos/contents.htm">Оглавление</a> || <a href="glava_25.htm" tppabs="http://ndesign.com.ua/~mik/doc/sos/glava_25.htm">Следующая глава</a><p>
<p><p>
<center><font size=1>
Copyright &copy <a href="cit.htm#1" tppabs="http://ndesign.com.ua/~mik/doc/sos/cit.htm#1">CIT</a>
</font></center>
</body></html>
