
<html>
<head>



<meta name="Description" content="Н. А. Олифер, В. Г. Олифер, Центр Информационных Технологий. Эмуляция BSD UNIX в Mach
">


<title>Эмуляция BSD UNIX в Mach
</title>
</HEAD><BODY bgcolor="#FFF5EE" text="#000000" link="#FF0000" alink="#FF0000" vlink="#A52A2A">

<h3><a name="_6_5">Эмуляция BSD UNIX в Mach</a></h3>
<p>
В ядре Mach имеется различные серверы, которые работают над ним. Наверно, наиболее важным сервером является программа, которая содержит большое количество кодов BSD UNIX (например, весь код файловой системы). Этот сервер представляет собой основной эмулятор UNIX. Такая конструкция - отражение реальной истории Mach как модифицированной версии BSD UNIX.
<p align=center>
<center><img src = "img00102.gif" tppabs="http://ndesign.com.ua/~mik/doc/sos/pictures/img00102.gif" border=1></center>

<p align=center>
<i>Рис. 6.15. Эмуляция UNIX в Mach</i>
<p>
Реализация механизма эмуляции UNIX в среде Mach состоит из двух частей, сервера UNIX и библиотеки эмуляции системных вызовов, как это показано на рисунке 6.15. Когда система стартует, сервер UNIX инструктирует ядро, чтобы оно перехватывало все прерывания системных вызовов и отображало вектора этих прерываний на адреса внутри библиотеки эмуляции процесса UNIX'а, по которым расположены обрабатывающие данные вызовы функции. Любой системный вызов, который делается UNIX-процессом, приводит к кратковременной передаче управления ядру, а затем к немедленной передаче управления библиотеке эмуляции. Значения машинных регистров в момент передачи управления библиотеке становятся теми же, что и в момент прерывания. Такой метод иногда называют методом батута.
<p>
Как только библиотека эмуляции получает управление, она проверяет регистры для того, чтобы определить, какой системный вызов нужно обработать. Затем библиотека делает вызов RPC другого процесса, сервера UNIX, который и должен выполнить эту работу. После завершения обработки вызова пользовательская программа снова получает управление. Эта передача управления не проходит через ядро.
<p>
Когда процесс <i>init</i> порождает потомков с помощью системного вызова fork, то они автоматически наследуют как библиотеку эмуляции, так и механизм батута, поэтому они могут выполнять системные вызовы UNIX.
<p>
Сервер UNIX реализован в виде набора С-нитей. Хотя некоторые нити управляют таймерами, работают с сетью и другими устройствами ввода-вывода, большинство нитей обрабатывают системные вызовы BSD. Библиотека эмуляции взаимодействует с этими нитями с использованием обычного механизма межпроцессного взаимодействия Mach.
<p>
Когда сообщение поступает на UNIX-сервер, его принимает свободная простаивающая нить, определяет, от какого процесса пришел вызов, извлекает номер системного вызова и параметры, выполняет системный вызов, и, наконец, отсылает ответ. Большинство сообщений соответствует точно одному системному вызову BSD.
<p>
Существует один набор системных вызовов, выполняющихся по другому - это вызовы операций ввода-вывода с файлами. Они могли бы выполняться и по описанной схеме, но из-за соображений производительности был реализован другой подход. Когда файл открывается, то он отображается непосредственно в адресное пространство вызывающего процесса, так что библиотека эмуляции получает к нему доступ непосредственно, без необходимости делать вызов RPC сервера UNIX. Например, чтобы выполнить системный вызов READ, библиотека эмуляции определяет место расположения байтов в отображенном файле, которые нужно прочитать, определяет место расположения буфера и просто копирует байты в буфер с максимально возможной скоростью.
<p>
Во время цикла копирования может случиться страничный отказ, если некоторые страницы файла не находятся в памяти. Каждый отказ приводит к тому, что Mach посылает сообщение внешнему менеджеру памяти, управляющему отображением файла. Этот менеджер памяти представляет собой нить внутри UNIX-сервера, называемую пейджером i-узла (i-node pager). Менеджер читает с диска нужную страницу файла и отображает ее в адресное пространство прикладной программы. Он также синхронизирует операции над файлами, которые открыты несколькими UNIX-процессами одновременно.
<p>
Хотя описанный метод выполнения программ UNIX и кажется запутанным, многочисленные измерения показали, что он работает лучше, чем традиционные монолитные реализации ядра. В дальнейшем работы над Mach будут фокусироваться на разделении сервера UNIX на несколько серверов с более специфическими функциями.

<p><center><a href="glava_27.htm" tppabs="http://ndesign.com.ua/~mik/doc/sos/glava_27.htm">Предыдущая глава</a> || <a href="contents.htm" tppabs="http://ndesign.com.ua/~mik/doc/sos/contents.htm">Оглавление</a> || <a href="glava_29.htm" tppabs="http://ndesign.com.ua/~mik/doc/sos/glava_29.htm">Следующая глава</a><p>
<p><p>
<center><font size=1>
Copyright &copy <a href="cit.htm#1" tppabs="http://ndesign.com.ua/~mik/doc/sos/cit.htm#1">CIT</a>
</font></center>
</body></html>
